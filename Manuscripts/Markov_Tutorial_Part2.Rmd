---
title: 'A Tutorial on Time-Dependent Cohort State-Transition Models in R'
author: 
  - Fernando Alarid-Escudero, PhD^[Division of Public Administration, Center for Research and Teaching in Economics (CIDE), Aguascalientes, AGS, Mexico]
  - Eline Krijkamp, MSc^[Department of Epidemiology, Erasmus University Medical Center, Rotterdam, The Netherlands]
  - Eva A. Enns, PhD^[Division of Health Policy and Management, University of Minnesota School of Public Health, Minneapolis, MN, USA]
  - Alan Yang, MSc^[The Hospital for Sick Children, Toronto]
  - Myriam G.M. Hunink, PhD$^\dagger$^[Center for Health Decision Sciences, Harvard T.H. Chan School of Public Health, Boston, USA]
  - Petros Pechlivanoglou, PhD^[The Hospital for Sick Children, Toronto and University of Toronto, Toronto, Ontario, Canada]
  - Hawre Jalal, MD, PhD^[University of Pittsburgh, Pittsburgh, PA, USA]
date: '`r Sys.Date()`'
documentclass: "article"
output:
  bookdown::pdf_book:
    fig_caption: yes
    keep_tex: yes
always_allow_html: yes
bibliography: WorkingPapers-CohortModelsR.bib
geometry: margin=1in
header-includes:
- \usepackage{amsmath}
- \usepackage{float}
- \usepackage{setspace}\onehalfspacing
- \usepackage[printwatermark]{xwatermark}
- \newwatermark[allpages,color=gray!20,angle=45,scale=2,xpos=0,ypos=0]{DRAFT, Do Not Share}
- \renewcommand{\contentsname}{}\vspace{-.5cm} # Removes heading of Contents
keywords: "Markov models, state-transition models, decision models, Tutorial, R"
link-citations: yes
csl: sage-vancouver.csl
site: bookdown::bookdown_site
tags:
- Markov models
- state-transition models
- decision models
- Tutorial
- R
abstract: |
  In an accompanying tutorial, we show how to implement time-independent cohort state-transition models (cSTMs) to conduct cost-effectiveness analyses (CEA) in R. In this tutorial, we introduce time-dependent cSTMs, where transition probabilities and rewards can depend on the time since the start of the simulation (simulation time-dependency) or on time spent in a health state (state residence). We illustrate how to conduct a CEA of multiple strategies using a time-dependent cSTM using a previously published cSTM, including probabilistic sensitivity analyses. We also demonstrate how to compute various epidemiological outcomes of interest, such as survival probability and prevalence. We provide a link to a public repository with all the R code described in this tutorial that readers can use to replicate the example or adapt for various decision modeling applications.
---
```{r, echo = FALSE}
## Journal Abbreviations
# library(RJSONIO)
# if(!file.exists("abbreviations.json")){
# download.file("https://ndownloader.figshare.com/files/5212423","wos_abbrev_table.csv")
#   abbrev <- read.csv("wos_abbrev_table.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
#   abbrev$full <- gsub("\\", "\\\\",abbrev$full, fixed = TRUE)
#   abbrev.list <- list('default' = list('container-title' = abbrev$abbrev.dots))
#   names(abbrev.list$default$`container-title`) = abbrev$full
#   write(toJSON(abbrev.list), "abbreviations.json")
#   rm(abbrev)
#   rm(abbrev.list)
# }
```

```{r setup, include=FALSE}
#install.packages(c("kableExtra", "scales", "dampack"))
library(knitr)
library(kableExtra) # https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales) # For dollar signs and commas
library(boot)
library(dampack)
# devtools::install_github("DARTH-git/darthtools")
library(darthtools)
knitr::opts_chunk$set(echo = TRUE)
doc_type <- knitr::opts_knit$get('rmarkdown.pandoc.to')

# Load cSTM and CEA functions
source("../R/Functions STM_02.R")


# Define parameters
cycle_length <- 1  # cycle length equal one year
n_age_init <- 25   # age at baseline
n_age_max  <- 100  # maximum age of follow up
n_cycles <- n_age_max - n_age_init # time horizon, number of cycles
# v_r_mort_by_age <- seq(0.001, 0.01, length.out = 100)
lt_usa_2005 <- read.csv("../data/LifeTable_USA_Mx_2015.csv")
v_r_mort_by_age <- lt_usa_2005 %>% 
  # filter(Age >= age & Age <= n_age_max) %>%
  select(Total) %>%
  as.matrix()

## General setup
v_names_states <- c("H", "S1", "S2", "D") # the 4 health states of the model:
                               # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n_states <- length(v_names_states) # number of health states 
d_c <- d_e <- 0.03 # equal discount of costs and QALYs by 3%
v_names_str <- c("Standard of care", # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 
n_str <- length(v_names_str)

## Transition probabilities (per cycle)
p_HS1   <- 0.15  # probability of becoming Sick when Healthy
p_S1H   <- 0.5   # probability of becoming Healthy when Sick
p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

# Effectiveness of treatment B
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B

## Transition probability of becoming Sicker when Sick for treatment B
# transform probability to rate
r_S1S2      <- -log(1-p_S1S2)
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when Sick for treatment B
r_S1S2_trtB <- r_S1S2 * hr_S1S2_trtB
# transform rate to probability
p_S1S2_trtB <- 1-exp(-r_S1S2_trtB*cycle_length) # probability to become Sicker when Sick 
                                                # under treatment B conditional on surviving

## Cost and utility inputs 
# State rewards
c_H   <- 2000  # cost of being Healthy for one cycle 
c_S1  <- 4000  # cost of being Sick for one cycle 
c_S2  <- 15000 # cost of being Sicker for one cycle
c_D   <- 0     # cost of being dead for one cycle
c_trtA <- 12000 # cost of treatment A for one cycle 
c_trtB <- 13000 # cost of treatment B for one cycle

u_H   <- 1     # utility of being Healthy for one cycle 
u_S1  <- 0.75  # utility of being Sick for one cycle 
u_S2  <- 0.5   # utility of being Sicker for one cycle
u_D   <- 0     # utility of being dead for one cycle
u_trtA <- 0.95  # utility when being treated for one cycle

# Transition rewards
du_HS1 <- 0.01  # disutility when transitioning from Healthy to Sick
ic_HS1 <- 1000  # increase in cost when transitioning from Healthy to Sick
ic_D   <- 2000  # increase in cost when dying

# PSA parameters
n_sim <- 1000 # Number of PSA samples
```

```{r figure-setup, echo=FALSE, include=FALSE}
## chunk will ensure that:
library(formatR)
# indent = 2: two spaces of indentation.
# tidy=TRUE puts formatR to work to produce a beautiful and standardized layout code.
if(!knitr:::is_html_output())
{
  # options("width"=56)
  knitr::opts_chunk$set(tidy.opts=list(indent = 1.5)) # width.cutoff=56, tidy = TRUE
  knitr::opts_chunk$set(fig.pos = 'H')
}

## chunk will ensure that:
# all the figures generated by the report will be placed in the figs/sub-directory
# all the figures will be 6.5 x 4 inches and centered in the text.
knitr::opts_chunk$set(fig.path="../figs/", fig.width=8, fig.height=6, fig.align="center")
```

# Introduction

Cohort state-transition models (cSTMs) are a type of decision model used to evaluate different health policy and clinical strategies, such as screening and surveillance programs,[@Suijkerbuijk2018; @Sathianathen2018a] diagnostic procedures,[@Lu2018b] disease management programs,[@Djatche2018] and interventions.[@Pershing2014; @Smith-Spangler2010]. cSTMs can be either time-independent or depend on either the time since the start of the simulation (simulation time-dependency) or on time spent in a health state (state residence). In an accompanying tutorial,[@Alarid-Escudero2021a] we describe the components of a time-independent cSTM, illustrate the implementation of these components and conduct a cost-effectiveness analysis (CEA) in R, a statistical software with an increasing use in health decision sciences.[@Jalal2017b] This tutorial focuses on time-dependent cSTM. We cover both simulation time-dependency and time dependency on state residence. We first expand the Sick-Sicker model described in the accompanying tutorial[@Alarid-Escudero2021a] to account for age dependency and time dependency on state residence and allowing for transition rewards. We then provide a description of each of the components of a time-dependent cSTM, illustrate the implementation of these components by expanding the example described in the accompanying tutorial, conduct a CEA comparing four strategies, including a probabilistic sensitivity analysis. We also demonstrate how to compute various epidemiological outcomes of interest, such as survival probability and prevalence. Readers can find the most up-to-date model code and code to create the tutorial graphs in the accompanying GitHub repository (https://github.com/DARTH-git/Cohort-modeling-tutorial). We assume that the reader is familiar with the basics of decision modeling and coding a time-independent cSTM in R. Thus, a prior introduction to R and linear algebra for decision modelers is recommended.

# Time-dependent cSTMs
Time-dependency in cSTMs means that transition probabilities or rewards are not fixed over time. Time dependency in cSTMs is desirable to represent disease processes over relatively long periods accurately. In this tutorial, we describe two types of time dependency: (1) dependency on time since simulation starts ("simulation-time dependency"), with age-specific background mortality being an important example,[@Snowsill2019] and (2) state-residence time dependency, which means that transition probabilities or rewards depend on the duration of time the cohort spends in a given state. Time-dependent cSTMs can capture the increasing age-specific background mortality as the cohort ages (age dependency) and dependency on the amount of time spent in a given state (state residence). We cover both types in this tutorial.

## Simulation-time dependency
Transition probabilities that depend on the time since the start of the simulation (simulation-time dependency) can be accounted for by the transition probability matrix being a function of time, $P_t$. From here after we will refer to time since the start of the simulation as \textit{simulation-time dependency}. The elements of $P_t$ are the transition probabilities of moving from state $i$ to state $j$ as a function of time $t$, $p_{[i,j,t]}$, where $\{i,j\} = 1,\ldots, n_S$ and $t = 0,\ldots,n_T$
$$
  P_t = 
  \begin{bmatrix}
    p_{[1,1,t]} & p_{[1,2,t]} & \cdots & p_{[1,n_S,t]} \\
    p_{[2,1,t]} & p_{[2,2,t]} & \cdots & p_{[2,n_S,t]} \\
    \vdots    & \vdots  & \ddots & \vdots   \\
    p_{[n_S,1,t]} & p_{[n_S,2,t]} & \cdots & p_{[n_S,n_S,t]} \\
  \end{bmatrix}.
$$
Note that all rows of the transition probability matrix in each cycle $t$ must sum to one, $\sum_{j=1}^{n_S}{p_{[i,j,t]}} = 1$ for all $i = 1,\ldots,n_S$ and $t = 0,\ldots, n_T$.

The state vector at cycle $t+1$ ($\mathbf{m}_{t+1}$) is then calculated as the matrix product of the state vector at cycle $t$, $\mathbf{m}_{t}$, and the transition probability matrix that the cohort faces in cycle $t$, $P_t$, such that,

$$
  \mathbf{m}_{t+1} = \mathbf{m}_{t} P_t \text{ for } t = 0,\ldots, (n_T - 1),
$$
where $\mathbf{m}_1$ is computed from $\mathbf{m}_{0}$ and represents the initial state vector with the distribution of the cohort across all health states at the start of the simulation (cycle 0). Then, this equation is iteratively evaluated until $t = n_T$. 

The cohort trace matrix, $M$, is a matrix of dimensions $(n_T+1) \times n_S$ where each row is a state vector $(-\mathbf{m}_{t}-)$, such that

$$
  M = 
  \begin{bmatrix}
    - \mathbf{m}_0 -  \\
    - \mathbf{m}_1 -  \\
     \vdots \\
    - \mathbf{m}_{n_T} -  
  \end{bmatrix}. 
$$
$M$ stores the output of the cSTM, which we can use to compute various epidemiological outcomes, such as prevalence and survival probability over time, and economic outcomes, such as cumulative resource use and costs. 

## Time dependency on state residence
A slightly more complex time dependency is *state residence*, for which transition probabilities or rewards depending on the time spent in a given state. One way to account for state-residence dependency is to expand the number of states with as many transient states as the number of cycles for which state residency is required.  These transient states are referred to as *tunnel* states where the cohort can stay for only one cycle and either transition to the next tunnel state or completely exit the tunnel. The set of tunnel states then essentially equals the amount of time that the cohort has spent in the tunnel representing a specific health state.

If state-residence in a given state lasts $n_{tunnels}$ cycles, such a state needs to be expanded into $n_{tunnels}$ states, and the transition probability matrix also needs to be expanded to incorporate these additional states. This will result in a transition probability matrix (or array if the transition probabilities are also dependent on simulation time) of dimensions $n_{S_{tunnels}} \times n_{S_{tunnels}}$ (or $n_{S_{tunnels}} \times n_{S_{tunnels}} \times n_T$), where $n_{S_{tunnels}}$ is the total number of health states ($n_{S_{tunnels}} = n_S + n_{tunnels} - 1$).


Table \@ref(tab:Timedep-cSTM-components-table) describes the elements related to the core components of time-dependent cSTMs and their suggested R code names. For a more detailed description of the variable types, data structure, R name for all cSTM elements, please see the Supplementary Material.

Table: (\#tab:Timedep-cSTM-components-table) Components of a time-dependent cSTM with their R name.

| Element | Description               | R name |   |
|---------|---------------------------|:------:|---|
| $n_S$   | Number of states          | `n_states`|   |
| $\mathbf{m}_0$   | Initial state vector      | `v_s_init` |   |
| $\mathbf{m}_t$   | State vector in cycle $t$ | `v_mt` |   |
| $M$     | Cohort trace matrix       | `m_M` |   |
| $\mathbf{P}$ | Time-dependent transition probability array | `a_P` |   |
| $\mathbf{A}$ | Transition-dynamics array | `a_A` |   |
| $n_{tunnels}$| Number of tunnel states | `n_tunnel size`|   |
| $n_{S_{tunnels}}$| Number of states including tunnel states | `n_states_tunnels` |   |
| $\mathbf{m}_{{tunnels}_0}$| Initial state vector for the model with tunnel states | `v_s_init_tunnels` |   |

# Case study: Time-dependent Sick-Sicker model

We expand the time-independent 4-state "Sick-Sicker" model[@Alarid-Escudero2021a] to account for time dependency. We first expand it to account for age dependency as an example of simulation time dependency. In a following section, we expand the age-dependent cSTM to account for time dependency in state residence  With the time-dependent cSTM, we conduct a CEA of different strategies accounting for transition rewards. Figure \@ref(fig:STD-Sick-Sicker) represents the state-transition diagram of the Sick-Sicker model. 

```{r STD-Sick-Sicker, echo=FALSE, fig.cap="State-transition diagram of the Sick-Sicker cohort state-transition model with the name of the health states and possible transitions with their corresponding transition probabilities.", fig.pos="H"}
knitr::include_graphics("figs/Sick-Sicker.png") 
```

The model simulates a cohort to quantify the expected costs and quality-adjusted life years (QALYs) for individuals at risk of a hypothetical disease that has two stages: "Sick" and "Sicker". 

All the parameters of the Sick-Sicker model and the corresponding R variable names are presented in Table \@ref(tab:param-table) and follow the notation described in the DARTH coding framework.[@Alarid-Escudero2019e] 
<!-- Briefly, we define variables by `<x>_<y>_<var_name>`, where `x` is the prefix that indicates the data type (e.g., scalar (no prefix), `v` for vector, `m` for matrix, `a` for array, `df` for data frame, etc.), `y` is the prefix indicating variable type (e.g., `p` for probability, `r` for rate, `hr` for hazard ratio, `lor` for log-odds ratio, `c` for cost `c`, `u`for utility, etc.), and `var_name` is some description of the variable presented separated by underscores. For example, `v_p_HDage` denptes the vector of transition probabilities from health state "H" to health state "D" that vary by age. In later sections we will define and name all the other parameters. -->

In the Sick-Sicker model, we simulate a hypothetical cohort of `r n_age_init`-year-old individuals over their lifetime (until a maximum age of 100 years) who all start in the "Healthy" state (denoted "H"). Meaning that we will simulate the cohort for `r n_cycles` cycles. The total number of cycles is denoted as $n_T$ and defined in R as `n_cycles`. Healthy individuals are at risk of developing the disease when they transition to the "Sick" state (denoted by "S1"). Once healthy individuals get sick, they incur a one-time utility decrement of 0.01 (`du_HS1`, a disutility of transitioning from H to S1) and a transition cost of \$`r comma(ic_HS1)` (`ic_HS1`) that reflects the acute impacts of developing the illness. Sick individuals are at risk of further progressing to a more severe disease stage, the "Sicker" health state (denoted by "S2"). In the state-residence time-dependent model, the risk progressing from S1 to S2 is a function of the duration of time spent in S1. Individuals in S1 can recover and return to H. However, once individuals reach S2, they cannot recover; that is, the probability of transitioning to S1 or H from S2 is zero. Individuals in H face age-specific background mortality, meaning that we model all-cause mortality as a function of age. Individuals in S1 and S2 face an increased hazard of death, compared to Healthy individuals, in the form of a hazard ratio (HR) of 3 and 10, respectively, relative to the background mortality hazard rate. Individuals in S1 and S2 also experience increased health care costs (in addition to a one-time cost of \$`r comma(ic_HS1)`) and reduced QoL compared to individuals in H. Once simulated individuals die, they transition to the absorbing "Dead" state (denoted by "D"), where they remain, and incur a one-time cost of \$`r comma(ic_D)` (`ic_D`) that reflects the expected acute care preceding death. All transitions between non-death states are assumed to be conditional on surviving each cycle. We simulated the evolution of the cohort in one-year discrete-time cycles. We discount both costs and QALYs at an annual rate of `r percent(d_c)`.

We are interested in evaluating the cost-effectiveness of four strategies: Strategy A, strategy B, a combination of A and B (Strategy AB), and the standard of care (strategy SoC). Strategy A involves administering treatment A that increases the QoL of individuals in S1 from `r u_S1` (utility without treatment, `u_S1`) to `r u_trtA` (utility with treatment A, `u_trtA`) and costs \$`r comma(c_trtA)` per year (`c_trtA`).[@Krijkamp2018] This strategy does not impact the QoL of individuals in S2, nor does it change the risk of becoming sick or progressing through the sick states. Strategy B uses treatment B to reduce only the rate of Sick individuals progressing to the Sicker state with a hazard ratio (HR) of `r hr_S1S2_trtB` (`hr_S1S2_trtB`) and costs  \$`r comma(c_trtB)` per year (`c_trtB`) and does not affect QoL. Strategy AB involves administering both treatments A and B.

We assume that it is not possible to distinguish between Sick and Sicker patients; therefore, individuals in both disease states receive the treatments. Note that for strategy A, the model has the same structure and identical transition probabilities to SoC. The only difference is the added cost of the treatment for S1 or S2, and QoL increases for S1. After comparing the four strategies in terms of expected QALYs and costs, we calculate the incremental cost per QALY gained between non-dominated strategies.

<!-- Source of table: https://www.tablesgenerator.com/markdown_tables# -->

Table: (\#tab:param-table) Description of parameters, their R variable name, base-case values and distribution.

|           **Parameter**            |  **R name** | **Base-case** |**Distribution**|
|:-----------------------------------|:-----------:|:-------------:|:--------------:|
| Number of cycles ($n_cycles$)      | `n_cycles`  | `r n_cycles` years |    -      |
| Names of health states ($n$)       | `v_names_states` | H, S1, S2, D  |    -           |
| Annual discount rate for costs     | `d_c`       |  3%           |    -           |
| Annual discount rate for QALYs     | `d_e`       |  3%           |    -           |
| Number of PSA samples ($K$)        | `n_sim`     | 1,000         |    -           |
| Annual transition probabilities conditional on surviving     |             |               |                |
| - Disease onset (H to S1)          | `p_HS1`     |  0.15         | beta(30, 170)  |
| - Recovery (S1 to H)               | `p_S1H`     |  0.5          | beta(60, 60)   |
| - Time-independent disease progression (S1 to S2) | `p_S1S2` |  0.105 | beta(84, 716) |
| - Time-dependent disease progression (S1 to S2) | `v_p_S1S2_tunnels` | | |
|   &nbsp;&nbsp;&nbsp;&nbsp;Weibull parameters |         |               | |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Scale ($\lambda$) | `p_S1S2_scale` |  0.08 | lognormal(log(0.08), 0.02) |
|   &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Shape ($\gamma$)  | `p_S1S2_shape` |  1.10 | lognormal(log(1.10), 0.05) |
| Annual mortality                   |             |               |                |
| - Age-dependent background mortality rate (H to D)| `v_r_HDage`    |  age-specific | -     |
| - Hazard ratio of death in S1 vs H | `hr_S1`     |  3.0          | lognormal(log(3.0), 0.01) |
| - Hazard ratio of death in S2 vs H | `hr_S2`     |  10.0         | lognormal(log(10.0), 0.02) |
| Annual costs                       |             |               |                |
| - Healthy individuals              | `c_H`       |  $2,000       | gamma(100.0, 20.0) |
| - Sick individuals in S1           | `c_S1`      |  $4,000       | gamma(177.8, 22.5) |
| - Sick individuals in S2           | `c_S2`      |  $15,000      | gamma(225.0, 66.7) |
| - Dead individuals                 | `c_D`       |  $0           | -              |
| - Cost of treatment A as an additional costs on individuals treated in S1 or S2 | `c_trtA` | $12,000 | gamma(576.0, 20.8) |
| - Cost of treatment B as an additional costs on individuals treated in S1 or S2 | `c_trtB` | $13,000 | gamma(676.0, 19.2) |
| Utility weights                    |             |               |                |
| - Healthy individuals              | `u_H`       |  1.00         | beta(200, 3)   |
| - Sick individuals in S1           | `u_S1`      |  0.75         | beta(130, 45)  |
| - Sick individuals in S2           | `u_S2`      |  0.50         | beta(230, 230)   |
| - Dead individuals                 | `u_D`       |  0.00         | -              |
| Treatment A effectiveness      |             |               |                |
| - Utility for treated individuals in S1 | `u_trtA` |  0.95        | beta(300, 15)  |
| Treatment B effectiveness      |             |               |                |
| - Reduction in rate of disease progression (S1 to S2) as hazard ratio (HR) | `hr_S1S2_trtB` | log(0.6) | lognormal(log(0.6), 0.1) |
| Transition rewards                 |             |               |                |
| - Utility decrement of healthy individuals | `du_HS1`|  0.01     | beta(11,1088)  |
|   when transitioning to S1         |             |               |                |
| - Cost of healthy individuals      | `ic_HS1`    |  $1,000       | gamma(25, 40)   |
|   when transitioning to S1         |             |               |             |
| - Cost of dying when transitioning to D | `ic_D` |  $2,000       | gamma(100, 20)   |

The R code below describes the initialization of the input parameters.

```{r Model-Params, eval=FALSE}
## General setup
cycle_length <- 1 # cycle length equal one year
n_age_init <- 25  # age at baseline
n_age_max  <- 100 # maximum age of follow up
n_cycles <- n_age_max - n_age_init # number of cycles
# The 4 health states of the model:
v_names_states <- c("H",  # Healthy (H)
                    "S1", # Sick (S1)
                    "S2", # Sicker (S2)
                    "D")  # Dead (D)
n_states <- length(v_names_states) # number of health states 
d_e <- 0.03 # discount rate for QALYs of 3% per cycle 
d_c <- 0.03 # discount rate for costs of 3% per cycle 
v_names_str <- c("Standard of care", # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 

## Transition probabilities (per cycle), hazard ratios and odds ratio (OR)
p_HS1   <- 0.15  # probability of becoming Sick when Healthy
p_S1H   <- 0.5   # probability of becoming Healthy when Sick
p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

# Effectiveness of treatment B
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B

## State rewards
## Costs
c_H    <- 2000  # cost of being Healthy for one cycle 
c_S1   <- 4000  # cost of being Sick for one cycle 
c_S2   <- 15000 # cost of being Sicker for one cycle
c_D    <- 0     # cost of being dead for one cycle
c_trtA <- 12000 # cost of receiving treatment A for one cycle
c_trtB <- 13000 # cost of receiving treatment B for one cycle 
# Utilities
u_H    <- 1     # utility of being Healthy for one cycle 
u_S1   <- 0.75  # utility of being Sick for one cycle 
u_S2   <- 0.5   # utility of being Sicker for one cycle
u_D    <- 0     # utility of being dead for one cycle
u_trtA <- 0.95  # utility when receiving treatment A for one cycle

## Transition rewards
du_HS1 <- 0.01  # one-time utility decrement when transitioning from Healthy to Sick
ic_HS1 <- 1000  # one-time cost when transitioning from Healthy to Sick
ic_D   <- 2000  # one-time cost when dying
```

## Simulation-time dependency
To illustrate the implementation of this time dependency in the Sick-Sicker cSTM, we model all-cause mortality as a function of age. It is common to obtain all-cause mortality from life tables in the form of age-specific mortality hazard rates, $\mu(a)$, where $a$ refers to age. For this example, we create a vector `v_r_mort_by_age` with age-specific background mortality hazard rates for 0 to 100 year-olds obtained from the 2015 US life-tables.[@Arias2017] To compute the transition probability from state H to state D, corresponding to cohort's age at each cycle, we transform $\mu(a)$ to a transition probability assuming a constant exponential hazard rate within each year of age
$$
  p_{[H,D,t]} = 1-\exp\left\{{-\mu(a_0 + t)}\right\},
$$ 
where $a_0 =$ `r n_age_init` is the starting age of the cohort. We will run the Sick-Sicker model for `r n_age_max - n_age_init` cycles for ages `r n_age_init` through `r n_age_max`. Instead of iterating through the mortality hazard rates, we obtain a vector of background mortality hazard rates for the ages of interest between `r n_age_init` through `r n_age_max` by subsetting \(\mu(a)\) (R variable name `v_r_mort_by_age`) for these ages. We transform the resulting R variable, `v_r_HDage`, to a probability.

```{r}
# Age-specific mortality rate in the Healthy state (background mortality)
v_r_HDage <- v_r_mort_by_age[(n_age_init + 1) + 0:(n_cycles - 1)]
# Transform to age-specific background mortality risk
v_p_HDage  <- 1 - exp(-v_r_HDage) 
```

Because mortality in S1 and S2 are relative to background mortality, adding age dependency on background mortality results in age-dependent mortality in S1 and S2 as well as in H. To generate the age-specific mortality in S1 and S2, we multiply the age-specific background mortality rate, `v_r_HDage`, by the constant hazard ratios `hr_S1` and `hr_S2`, respectively. We then convert the resulting stage-specific mortality rates to probabilities to ensure that the transition probabilities to D are bounded between 0 and 1.

```{r}
## Age-specific mortality rates in the Sick and Sicker states
v_r_S1Dage <- v_r_HDage * hr_S1 # when Sick
v_r_S2Dage <- v_r_HDage * hr_S2 # when Sicker
## Age-specific probabilities of dying in the Sick and Sicker states
v_p_S1Dage <- 1 - exp(-v_r_S1Dage) # when Sick
v_p_S2Dage <- 1 - exp(-v_r_S2Dage) # when Sicker
```

To incorporate age-dependency into the transition probability matrix, we expand the dimensions of the matrix and create a 3-dimensional transition probability array, $\mathbf{P}$ and `a_P` in R, of dimensions $n_S \times n_S \times n_T$, where the first two dimensions correspond to transitions between states and the third dimension to time. The $t$-th element in the third dimension corresponds to the transition probability matrix at cycle $t$. A visual representation of `a_P` is shown in Figure \@ref(fig:Array-Time-Dependent).

```{r Array-Time-Dependent, echo=FALSE, out.width='100%', fig.cap="A 3-dimensional representation of the transition probability array of the age-dependent Sick-Sicker model with simulation-time dependency.",fig.pos="H"}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-without-tunnels.png")
```

First, we initialize `a_P` with a default value of zero for all transition probabilities.

```{r Init-Sick-Sicker-TimeDep-P}
# Initialize the transition probability array
a_P <- array(0, dim = c(n_states, n_states, n_cycles),
              dimnames = list(v_names_states, v_names_states, 0:(n_cycles - 1)))
```

Filling `a_P` with the corresponding transition probabilities of the cohort under the SoC strategy is comparable with filling `m_P` for a time-independent cSTM, accounting for the time dimension, which is represented by the third dimension of the array. However, this requires a slight modification of the code from the time-independent cSTM. The code below illustrates how to assign age-dependent transition probabilities in the third dimension of the array. For those transitions that are constant over time, we only need to provide one transition probability. R replicates the value of such transitions as many times as the length of the time dimension, for our example $n_T+1$ times.

```{r Sick-Sicker-TimeDep-P}
### Fill in array
## From H
a_P["H", "H", ]   <- (1 - v_p_HDage) * (1 - p_HS1)
a_P["H", "S1", ]  <- (1 - v_p_HDage) * p_HS1
a_P["H", "D", ]   <- v_p_HDage
## From S1
a_P["S1", "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2))
a_P["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2
a_P["S1", "D", ]  <- v_p_S1Dage
## From S2
a_P["S2", "S2", ] <- 1 - v_p_S2Dage
a_P["S2", "D", ]  <- v_p_S2Dage
## From D
a_P["D", "D", ]   <- 1
```

As mentioned above, each of the elements on the third dimension of `a_P` correspond to a transition probability matrix. For example, the transition matrix for 25-year-olds in the Sick-Sicker model under the SoC strategy can be retrieved using:

```{r Transition-Probability-Array-1}
a_P[, , 1]
```

Similar to the time-independent cSTM, treatment A does not change the transition probabilities. For treatment B, we first initialize the three-dimensional array of transition probabilities, `a_P_trtB` as a copy of `a_P` and update only the transition probabilities from S1 to S2 (i.e., `p_S1S2` is replaced with `p_S1S2_trtB`).

```{r Sick-Sicker-Time-Dependent-Age-New-Treatment2}
## Initialize transition probability array for treatment B
a_P_trtB <- a_P
## Update only transition probabilities from S1 involving p_S1S2
a_P_trtB["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2_trtB))
a_P_trtB["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2_trtB
```

Once we create both three-dimensional transition probability arrays, we check they are valid using the functions `check_sum_of_transition_array` and `check_transition_probability`,which are provided in the `darthtools` package (https://github.com/DARTH-git/darthtools).

```{r}
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P)
check_transition_probability(a_P_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P,      n_states = n_states, n_cycles = n_cycles)
check_sum_of_transition_array(a_P_trtB, n_states = n_states, n_cycles = n_cycles)
```

For the time-dependent Sick-Sicker model, the entire cohort starts in the Healthy state. Therefore, we create the $1 \times n_S$ initial state vector `v_s_init` with all of the cohort assigned to the H state:
```{r Sick-Sicker-s0}
v_s_init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
v_s_init
```

We use the variable `v_s_init` to initialize $M$ represented by `m_M` for the cohorts under SoC strategy and strategy A because the transition probabilities are the same under both strategies, and by `m_M_trtB` for the cohorts under strategies B and AB because both transition probabilities under both strategies are affected by treatment B. Note that the initial state vector, `v_s_init`, can be modified to account for the distribution of the cohort across the states at the start of the simulation and might vary by strategy. To simulate the cohort over the $n_T$ cycles for the age-dependent cSTM, we initialize two new cohort trace matrices `m_M_ad` and `m_M_ad_trtB`.

```{r Init-Sick-Sicker-TimeDependent-Trace}
## Initialize cohort trace for age-dependent (ad) cSTM under SoC
m_M_ad <- matrix(NA, 
                 nrow = (n_cycles + 1), ncol = n_states, 
                 dimnames = list(0:n_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_ad[1, ] <- v_s_init
## Initialize cohort trace under treatment B
m_M_ad_trtB <- m_M_ad # structure and initial states remain the same.
```

We then use the matrix product to get the state vector at cycle $t$. This equation is similar to the one described for the time-independent model. The only modification required is to index the transition probability arrays `a_P` and `a_P_trtB` by $t$ to obtain the cycle-specific transition probability matrices.

```{r Sick-Sicker-TimeDependent-Solution}
# Iterative solution of age-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_ad[t + 1, ] <- m_M_ad[t, ] %*% a_P[, , t]
  # For treatment B
  m_M_ad_trtB[t + 1, ] <- m_M_ad_trtB[t, ] %*% a_P_trtB[, , t]
}
```

A graphical representation of the cohort trace for all cycles of the age-dependent cSTM under strategies SoC and A is shown in Figure \@ref(fig:Sick-Sicker-Trace-AgeDep).

```{r Sick-Sicker-Trace-AgeDep, echo=FALSE, fig.cap='Cohort trace of the age-dependent cSTM under strategies SoC and A.', message=FALSE, warning=FALSE, fig.pos="H"} 
cols <- get_DARTH_cols()
lty <-  c("H" = 1, "S1" = 2, "S2" = 4, "D" = 3)
ggplot(melt(m_M_ad), aes(x = Var1, y = value, 
                         color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_color_manual(name = "Health state", values = cols) +
  scale_linetype_manual(name = "Health state", values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill = NA))
```

## Time dependency on state residence
To illustrate state-residence dependency in the age-dependent Sick-Sicker model defined above, we assume the risk of progression from S1 to S2 increases the longer the cohort has been Sick. This increase follows a Weibull hazard function, defined as 
$$
  p_{\left[S1_{\tau},S2, \tau\right]} = \lambda \gamma \tau^{(\lambda-1)},
$$
where $\tau = 1, \ldots, n_{tunnels}$ represents the duration that the cohort has been in S1, and $\lambda$ and $\gamma$ are the scale and shape parameters of the Weibull function, respectively. We assume that state-residence dependency lasts the whole simulation (i.e., $n_{tunnels}=n_T$) and create a new variable called `n_tunnel_size` with the length of the tunnel equal to `n_cycles`. Thus, there will be `r n_cycles` S1 tunnel states plus `r (n_states-1)` more states (H, S2, D) resulting in a total of $n_{S_{tunnels}}$ = `r (n_states-1) + n_cycles`.

Figure \@ref(fig:STD-Sick-Sicker-tunnels) shows the Sick-Sicker model's state-transition diagram with state-residence dependency with $n_{tunnels}$ tunnel states for S1.
 
```{r STD-Sick-Sicker-tunnels, echo=FALSE, out.width='100%', fig.cap="State-transition diagram of the Sick-Sicker model with tunnel states expanding the Sick state ($S1_1, S1_2,...,S1_{n_{tunnels}}$).", fig.pos="H"}
knitr::include_graphics("figs/Sick-Sicker-with-tunnels.png")
```

To implement state residency in the Sick-Sicker model using tunnels, we create the vector variables `v_Sick_tunnel` and `v_names_states_tunnels` with the Sick tunnel states' names and all the states of the cSTM with tunnels, respectively, and use the tunnel-specific parameters listed in Table \@ref(tab:Timedep-cSTM-components-table).

```{r}
## Number of tunnels
n_tunnel_size <- n_cycles 
## Name for tunnel states of Sick state
v_Sick_tunnel <- paste("S1_", seq(1, n_tunnel_size), "Yr", sep = "")
## Create variables for model with tunnels
v_names_states_tunnels <- c("H", v_Sick_tunnel, "S2", "D") # state names
n_states_tunnels <- length(v_names_states_tunnels)         # number of states
## Initialize first cycle of Markov trace accounting for the tunnels
v_s_init_tunnels <- c(1, rep(0, n_tunnel_size), 0, 0) 
```

Based on the updated parameters, the state-residence-dependent transition probability from Sick to Sicker based on a Weibull function, `v_p_S1S2_tunnels`, is: 
```{r}
# Weibull parameters
p_S1S2_scale <- 0.08 # scale
p_S1S2_shape  <- 1.1  # shape
# Weibull function
v_p_S1S2_tunnels <- p_S1S2_scale * p_S1S2_shape *
  (1:n_tunnel_size)^{p_S1S2_shape-1}
```

To adapt the 3-dimensional transition probability array to incorporate both age and state-residence dependence in the Sick-Sicker model under SoC, we first create an expanded 3-dimensional array accounting for tunnels, `a_P_tunnels`, of dimensions $n_{S_{tunnels}} \times n_{S_{tunnels}} \times n_T$. A visual representation of `a_P_tunnels` of the Sick-Sicker model with tunnel states expanding the Sick state is shown in Figure \@ref(fig:Array-Time-Dependent-Tunnels).

```{r Init-Sick-Sicker-TimeDep-P-tunnels}
# Initialize array
a_P_tunnels <- array(0, dim = c(n_states_tunnels, n_states_tunnels, n_cycles),
                     dimnames = list(v_names_states_tunnels, 
                                     v_names_states_tunnels, 
                                     0:(n_cycles - 1)))
```

```{r Array-Time-Dependent-Tunnels, echo=FALSE, out.width='100%', fig.cap="The 3-dimensional transition probability array of the Sick-Sicker model expanded to account for age-dependence and S1 state-residence using tunnel states.", fig.pos="H"}
knitr::include_graphics("figs/3D-state-transition-array-sick-sicker-tunnels.png")
```

Filling `a_P_tunnels` with the corresponding transition probabilities is similar to the `a_P` above, with the difference being that we now fill the transition probabilities from all the S1 tunnel states by iterating through all the tunnel states and assigning the corresponding disease progression transition probabilities.

```{r Sick-Sicker-TimeDep-P-tunnels}
### Fill in array
## From H
a_P_tunnels["H", "H", ]              <- (1 - v_p_HDage) * (1 - p_HS1)
a_P_tunnels["H", v_Sick_tunnel[1], ] <- (1 - v_p_HDage) * p_HS1
a_P_tunnels["H", "D", ]              <- v_p_HDage
## From S1
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ]   <- (1 - v_p_S1Dage) *
                                           (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  a_P_tunnels[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels[i]
  a_P_tunnels[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# Repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) *
                                               (1 - (p_S1H + v_p_S1S2_tunnels[n_tunnel_size]))
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) * 
                                                     v_p_S1S2_tunnels[n_tunnel_size]
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
### From S2
a_P_tunnels["S2", "S2", ] <- 1 - v_p_S2Dage
a_P_tunnels["S2", "D", ]  <- v_p_S2Dage
# From D
a_P_tunnels["D", "D", ] <- 1
```

Accounting for the effectiveness of treatment B is similar to the age-dependent approaches. We first transform `v_p_S1S2_tunnels` to a vector of rates, `v_r_S1S2_tunnels`, assuming exponentially distributed transitions across the tunnel states, and multiply times the hazard ratio of treatment B. Then, we transform back to probabilities to produce `v_p_S1S2_tunnels_trtB`, a vector of transition probabilities that account for the duration of S1 state-residence under treatment B.

```{r}
## Transform risk of progression from Sick to Sicker to a rate
# vector of rates of becoming Sicker when Sick
v_r_S1S2_tunnels <- -log(1-v_p_S1S2_tunnels)/cycle_length
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when 
# Sick for treatment B
r_S1S2_tunnels_trtB <- v_r_S1S2_tunnels * hr_S1S2_trtB
# transform rate to probability to become Sicker when Sick under treatment B 
# conditional on surviving
v_p_S1S2_tunnels_trtB <- 1-exp(-r_S1S2_tunnels_trtB*cycle_length) 
```

Then, we initialize the three-dimensional transition probability array for treatment B, `a_P_tunnels_trtB`, based on `a_P_tunnels`. The only difference is that we update only the transition probabilities from S1 involving `v_p_S1S2_tunnels` to using `v_p_S1S2_tunnels_trtB` instead.

```{r Sick-Sicker-Time-Dependent-State-Residence-New-Treatment2}
## Initialize transition probability array for treatment B
a_P_tunnels_trtB <- a_P_tunnels
## Update only transition probabilities from S1 involving v_p_S1S2_tunnels
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels_trtB[v_Sick_tunnel[i], "H", ] <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels_trtB[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ] <- (1 - v_p_S1Dage) * 
                                         (1 - (p_S1H + v_p_S1S2_tunnels_trtB[i]))
  a_P_tunnels_trtB[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels_trtB[i]
  a_P_tunnels_trtB[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "H", ] <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) * 
                                               (1 - (p_S1H +v_p_S1S2_tunnels_trtB[n_tunnel_size]))
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) *
                                                           v_p_S1S2_tunnels_trtB[n_tunnel_size]
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
```

Once we create both three-dimensional transition probability arrays with tunnels, we check they are valid.

```{r}
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P_tunnels)
check_transition_probability(a_P_tunnels_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P_tunnels,      n_states = n_states_tunnels, 
                              n_cycles = n_cycles)
check_sum_of_transition_array(a_P_tunnels_trtB, n_states = n_states_tunnels, 
                              n_cycles = n_cycles)
```

To simulate the cohort over the $n_T$ cycles for the state-residence cSTM, we initialize two new cohort trace matrices for the SoC and treatment B, `m_M_tunnels` and `m_M_tunnels_trtB`, respectively.  The dimensions of both matrices are $(n_T+1) \times n_{S_{tunnels}}$.

```{r Init-Sick-Sicker-TimeDependent-Tunnels-Trace}
# Initialize cohort for state-residence cSTM under SoC
m_M_tunnels <- matrix(0, 
                      nrow = (n_cycles + 1), ncol = n_states_tunnels, 
                      dimnames = list(0:n_cycles, v_names_states_tunnels))
# Store the initial state vector in the first row of the cohort trace
m_M_tunnels[1, ] <- v_s_init_tunnels
## Initialize cohort trace under treatment B
m_M_tunnels_trtB <- m_M_tunnels
```

and then we use the matrix product, similar to the age-dependent cSTM, to generate the full cohort trace

```{r Sick-Sicker-TimeDependent-Tunnels-Solution}
# Iterative solution of state-residence-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_tunnels[t + 1, ] <- m_M_tunnels[t, ] %*% a_P_tunnels[, , t]
  # Under treatment B
  m_M_tunnels_trtB[t + 1,] <- m_M_tunnels_trtB[t, ] %*% a_P_tunnels_trtB[, , t]
}
```

To compute a summarized cohort trace under SoC comparable with the time-independent and age-dependent cSTM, we aggregate over the tunnel states of S1 in each cycle (Figure \@ref(fig:Sick-Sicker-Trace-HistDep)).

```{r}
# Create aggregated trace
m_M_tunnels_sum <- cbind(H = m_M_tunnels[, "H"], 
                         S1 = rowSums(m_M_tunnels[, which(v_names_states=="S1"):
                                                    (n_tunnel_size +1)]), 
                         S2 = m_M_tunnels[, "S2"],
                         D = m_M_tunnels[, "D"])
```

```{r Sick-Sicker-Trace-HistDep, echo=FALSE, fig.cap='Cohort trace of the age-dependent cSTM accounting for state-residence dependency under strategies SoC and A.', message=FALSE, warning=FALSE, fig.pos="H"} 
cols <- get_DARTH_cols()
lty <-  c("H" = 1, "S1" = 2, "S2" = 4, "D" = 3)
ggplot(melt(m_M_tunnels_sum), aes(x = Var1, y = value, 
                         color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_color_manual(name = "Health state", values = cols) +
  scale_linetype_manual(name = "Health state", values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill = NA))
```
# Epidemiological and economic outputs
cSTMs can be used to generate different epidemiological and economic outputs. In a CEA, the main outcomes are typically the total expected QALYs and total costs accrued by the cohort over a predefined time horizon. However, epidemiological outcomes are often used to produce other measures of interest or model calibration and validation. Some common epidemiological outcomes include survival, prevalence, incidence, the average number of events, and lifetime risk of events.[@Siebert2012c]

## Epidemiological outcomes
In this tutorial, we provide the epidemiological definition of some of these outcomes and how they can be generated from a cSTM using the age-dependent Sick-Sicker cSTM under SoC. In the supplementary material, we provide the code to generate these outcomes from the state-residence-dependent cSTM.

### Survival probability
The survival function, $S(t)$, captures the probability of the cohort remaining alive by cycle $t$. To estimate $S(t)$ from the simulated cohort of the age-dependent Sick-Sicker model, shown in Figure \@ref(fig:Sick-Sicker-Surv-AgeDep), we sum the proportions of the non-death states for all $n_T$ cycles in `m_M_ad`.

```{r Sick-Sicker-TimeDependent-Surv}
v_S_ad <- rowSums(m_M_ad[, -which(v_names_states=="D")]) # vector with survival curve
``` 

```{r Sick-Sicker-Surv-AgeDep, echo=FALSE, fig.cap='Survival curve of the age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 0:n_cycles, Survival = v_S_ad), 
       aes(x = Cycle, y = Survival)) +
  geom_line(size = 1.3) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  xlab("Cycle") +
  ylab("Proportion alive") +
  theme_bw(base_size = 16) +
  theme()
```

### Prevalence
Prevalence is defined as the proportion of the population or cohort with a specific condition (or being in a particular health state) among those alive.[@Rothman2008h] To calculate the prevalence of S1 at cycle $t$, $\text{prev}(t)_i$, we compute the ratio between the proportion of the cohort in S1 and the proportion alive at that cycle.[@Keiding1991] The proportion of the cohort alive is given by the survival probability $S(t)$ defined above. The individual prevalence of the S1 and S2 health states and the overall prevalence of sick individuals (i.e., S1 + S2) of the age-dependent Sick-Sicker cSTM at each cycle $t$ is computed as follows and are shown in Figure \@ref(fig:Sick-Sicker-Prev-AgeDep).

```{r Sick-Sicker-TimeDependent-Prevalence}
v_prev_S1   <- m_M_ad[, "S1"] / v_S_ad          # vector with prevalence of Sick
v_prev_S2   <- m_M_ad[, "S2"] / v_S_ad          # vector with prevalence of Sicker
v_prev_S1S2 <- rowSums(m_M_ad[, c("S1", "S2")])/v_S_ad # prevalence of Sick and Sicker
```

```{r Sick-Sicker-Prev-AgeDep, echo=FALSE, fig.cap='Prevalence of sick states in age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"} 
df_prev_states <- data.frame(Cycle = 0:n_cycles, 
                  States  = ordered(rep(c("S1", "S2", "S1 + S2"),
                                each = (n_cycles + 1)), 
                                levels = c("S1", "S2", "S1 + S2")), 
                  Prevalence = c(v_prev_S1, 
                                 v_prev_S2, 
                                 v_prev_S1S2))
ggplot(df_prev_states, 
       aes(x = Cycle, y = Prevalence, 
           color = States, linetype = States)) +
  geom_line(size = 1) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + 
  scale_color_discrete(name = "Health State", l = 50) +
  scale_linetype(name = "Health State") +
  xlab("Cycle") +
  ylab("Prevalence (%)") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom")
```

Another epidemiological outcome that could be of interest, is the proportion S1 among all individuals with the disease. To compute this outcome at each cycle $t$, we divide $m_{[S2, t]}$ by $\text{prev}(t)_{\{S1,S2\}}$ where $t>0$, as presented in Figure \@ref(fig:Sick-Sicker-PropS2-AgeDep). Note that $t$ does not start at 0 because it takes one cycle for the cohort to get sick.

```{r Sick-Sicker-TimeDependent-PropS2}
# Vector with proportion of Sicker among sick individuals
v_prop_S2 <- m_M_ad[-1, "S2"] / v_prev_S1S2[-1] 
```

```{r Sick-Sicker-PropS2-AgeDep, echo=FALSE, fig.cap='Proportion of Sicker (S2) individuals among all sick patients of age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"} 
ggplot(data.frame(Cycle = 1:n_cycles, 
                  Proportion = v_prop_S2), 
       aes(x = Cycle, y = Proportion)) +
  geom_line(size = 1) +
  scale_y_continuous(breaks = number_ticks(6)) + # labels = scales::percent
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion") +
  theme_bw(base_size = 16) +
  theme()
```

### Life expectancy
Life expectancy (LE) refers to the expected number of years remaining to be alive.[@Lee2003a] In continuous-time, LE is the area under the entire survival curve.[@Klein2003]

$$
LE = \int_{t=0}^{\infty}{S(t) dt}.
$$

In discrete-time using cSTMs, we often calculate LE over a fixed time horizon at which most of the cohort has transitioned to the Dead state, $n_T$, and is defined as

$$
  LE = \sum_{t=0}^{n_T}{S(t)}.
$$

```{r Expected-life-years-NoShow, echo=FALSE}
le_ad <- sum(v_S_ad)
```

In the age-dependent Sick-Sicker model, where we simulated a cohort over  $n_T$= `r n_cycles` cycles, life expectancy `le_ad` is `r round(le_ad, 1)` cycles, which is calculated as

```{r Life-expectancy, eval=FALSE}
le_ad <- sum(v_S_ad) # life expectancy
```

Note that this equation expresses LE in the units of $t$. We use an annual cycle length; thus, the resulting LE will be in years. Analysts can also use other cycle lengths (e.g., monthly or daily), but the LE must be correctly converted to the desired unit if different than the cycle length units.

## Economic outcomes
In CEA, we can calculate economic outcomes by using either state or transition rewards. A "state reward" refers to a value assigned to individuals for being in a given state. In a cost-utility context, these could be either utilities or costs associated with remaining in a specific health state for one cycle. In the accompanying tutorial, we describe how to incorporate state rewards in CEA.[@Alarid-Escudero2021a] A "transition reward" refers to the increase or decrease in either costs or utilities of transitioning from one state to another, which may be associated with a one-time cost or utility impact. 

### State rewards
For the Sick-Sicker model, we create a vector of utilities and costs for each of the four strategies considered. The vectors of utilities and costs, `v_u_SoC` and `v_c_SoC`, respectively, contain the utilities and costs corresponding with being in each of the four health states under SoC which are shown in Table \@ref(tab:param-table).

```{r State-rewards-UC}
# Vector of state utilities under SOC
v_u_SoC <- c(H = u_H, S1 = u_S1, S2 = u_S2, D = u_D)
# Vector of state costs under SoC
v_c_SoC <- c(H = c_H, S1 = c_S1, S2 = c_S2, D = c_D)
```

We account for the benefits and costs of both treatments individually and their combination to create the state-reward vectors under treatments A and B (strategies A and B, respectively) and when applied jointly (strategy AB). Only treatment A affects QoL, so we create a vector of utilities for strategy A, `v_u_strA`, where we substitute the utility of being in S1 under SOC, `u_S1`, with the utility associated with the benefit of treatment A in being in that state, `u_trtA`. Treatment B does not affect QoL, so the vector of utilities for strategy B, `v_u_strB`, is the same as for SoC However, when both treatments A and B are applied jointly (strategy AB), the resulting vector of utilities `v_u_strAB` equals that of strategy A.

```{r State-rewards-U-Tr}
# Vector of state utilities for strategy A
v_u_strA <- c(H = u_H, S1 = u_trtA, S2 = u_S2, D = u_D)
# Vector of state utilities for strategy B
v_u_strB <- v_u_SoC
# Vector of state utilities for strategy AB
v_u_strAB <- v_u_strA
```

Both treatments A and B incur a cost. To create the vector of state costs for strategy A, `v_c_strA`, we add the cost of treatment A, `c_trtA`, to the state costs of S1 and S2. Similarly, when constructing the vector of state costs for strategy B, `v_c_strB`, we add the cost of treatment B, `c_trtB`, to the state costs of S1 and S2. Finally, for the vector of state costs for strategy AB, `v_c_strAB`, we add both treatment costs to the state costs of S1 and S2.

```{r State-rewards-C-Tr}
# Vector of state costs for strategy A
v_c_strA <- c(H  = c_H, 
              S1 = c_S1 + c_trtA, 
              S2 = c_S2 + c_trtA, 
              D  = c_D)
# Vector of state costs for strategy B
v_c_strB <- c(H  = c_H, 
              S1 = c_S1 + c_trtB, 
              S2 = c_S2 + c_trtB, 
              D  = c_D)
# Vector of state costs for strategy AB
v_c_strAB <- c(H  = c_H, 
               S1 = c_S1 + (c_trtA + c_trtB), 
               S2 = c_S2 + (c_trtA + c_trtB), 
               D  = c_D)
```

<!-- To compute the expected QALYs and costs for the age-dependent Sick-Sicker model under SoC and strategy A, we multiply the cohort trace matrix, `m_M_ad`, times the corresponding strategy-specific state vectors of rewards. Similarly, To compute the expected rewards for strategies B and AB, we multiply the cohort trace matrix accounting for the effectiveness of treatment B, `m_M_ad_trtB`, times their corresponding state vectors of rewards. -->

<!-- ```{r Expected-outcomes-each-cycle} -->
<!-- # Vector of QALYs under SoC -->
<!-- v_qaly_SoC <- m_M_ad %*% v_u_SoC -->
<!-- # Vector of costs under SoC -->
<!-- v_cost_SoC <- m_M_ad %*% v_c_SoC -->
<!-- # Vector of QALYs for strategy A -->
<!-- v_qaly_strA <- m_M_ad %*% v_u_strA -->
<!-- # Vector of costs for strategy A -->
<!-- v_cost_strA <- m_M_ad %*% v_c_strA -->
<!-- # Vector of QALYs for strategy B -->
<!-- v_qaly_strB <- m_M_ad_trtB %*% v_u_strB -->
<!-- # Vector of costs for strategy B -->
<!-- v_cost_strB <- m_M_ad_trtB %*% v_c_strB -->
<!-- # Vector of QALYs for strategy AB -->
<!-- v_qaly_strAB <- m_M_ad_trtB %*% v_u_strAB -->
<!-- # Vector of costs for strategy AB -->
<!-- v_cost_strAB <- m_M_ad_trtB %*% v_c_strAB -->
<!-- ``` -->

### Transition rewards
In the Sick-Sicker model, we previously mentioned that dying (i.e., transitioning to the Dead state) incurs a one-time cost of `r dollar(ic_D)` that reflects the acute care that might be received immediately preceding death. This one-time cost could include emergency services, hospitalization, or other healthcare utilization to address the ultimately fatal health complication. We also have a utility decrement and a cost increment on the transition from H to S1. Whereas the cost and utility of S1 reflect the cost and utility of being chronically sick, respectively, transition rewards capture the short-term impact of the acute events of becoming sick, such as hospitalization, stabilization, and so on.

Incorporating transition rewards requires keeping track of the proportion of the cohort that transitions between health states in each cycle while capturing what the states of origin and destination are. The cohort trace, $M$, does not capture this information. However, recovering this information is relatively straightforward and has been described in detail by Krijkamp et al. (2020).[@Krijkamp2019] Briefly, this approach involves changing the core computation in a traditional cSTM, from $m_t P_t$ to $\text{diag}(m_t) P_t$. This simple change allows us to compute the proportion of the cohort that transitions between the states of origin and destination in cycle $t$. The result is no longer a cohort trace matrix, but rather a three-dimensional array that we refer to as a transition-dynamics array ($\mathbf{A}$) with dimensions \(n_S \times n_S \times [n_T+1]\). The $t-$th slice of $\mathbf{A}$, $A_t$, is a matrix that stores the proportion of the population that transition between states of origin and destination between cycles $t-1$ and $t$. Similarly, we define the transition rewards by the states of origin and destination.

To account for both state and transition rewards, create a *matrix* of rewards $R_t$ of dimensions $n_S \times n_S$. The off-diagonal entries of $R_t$ store the transition rewards, and the diagonal of $R_t$ stores the state rewards for cycle $t$ and assumes that rewards occur at the beginning of the cycle.\textsuperscript{\protect\hyperlink{ref-Krijkamp2019}{22}} Finally, we multiply this matrix by $A_t$, the $t$-th slice of $A$, apply discounting, within-cycle correction, and compute the overall reward for each strategy outcome. Below, we illustrate these concepts in R.

To compute $\mathbf{A}$ for the age-dependent Sick-Sicker model under SOC, we initialize a three-dimensional array `a_A` of dimensions $n_S \times n_S \times [n_T+1]$ and set the diagonal of the first slice to the initial state vector `v_s_init`. We create a three-dimensional array for the cohort under treatment B, `a_A_trtB`, as a copy of the array under SoC.

```{r Init-Transition-Array}
# Initialize transition-dynamics array under SoC
a_A <- array(0,
             dim = c(n_states, n_states, (n_cycles + 1)),
             dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Set first slice to the initial state vector in its diagonal
diag(a_A[, , 1]) <- v_s_init
# Initialize transition-dynamics array under treatment B
a_A_trtB <- a_A
```

We then compute a matrix multiplication between a diagonal matrix of each of the $t$-th rows of the cohort trace matrix under SoC and treatment B, denoted as `diag(m_M_ad[t, ])` and `diag(m_M_ad_trtB[t, ])`, by the $t$-th matrix of the array of transition matrices, `a_P[, , t]` and `a_P_trtB[, , t]`, respectively,  over all $n_T$ cycles.

```{r Compute-Transition-Array}
# Iterative solution to produce the transition-dynamics array
for (t in 1:n_cycles){
  # For SoC
  a_A[, , t + 1] <- diag(m_M_ad[t, ]) %*% a_P[, , t]
  # For treatment B
  a_A_trtB[, , t + 1] <- m_M_ad_trtB[t, ]  * a_P_trtB[, , t]
}
```

To create the arrays of rewards for costs and utilities for the age-dependent Sick-Sicker cSTM, we create strategy-specific three-dimensional arrays of rewards and fill each of their rows across the third dimension with the vector of state rewards.

```{r Init-Reward-Array}
# Arrays of state and transition rewards
# Utilities under SoC
a_R_u_SoC <- array(matrix(v_u_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under SoC
a_R_c_SoC <- array(matrix(v_c_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy A
a_R_u_strA <-  array(matrix(v_u_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy A
a_R_c_strA <- array(matrix(v_c_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy B
a_R_u_strB <-  array(matrix(v_u_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy B
a_R_c_strB <- array(matrix(v_c_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy AB
a_R_u_strAB <-  array(matrix(v_u_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy AB
a_R_c_strAB <- array(matrix(v_c_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
```

To account for the transition rewards, we either add or subtract them in the corresponding location of the reward matrix representing the transitions of interest. For example, to account for the disutility of transitioning from H to S1 for strategy A, we subtract the disutility to the entry of the array of rewards corresponding to the transition from H to S1 across all cycles.

```{r Add-DisUtility-Tr}
# Add disutility due to transition from Healthy to Sick
a_R_u_strA["H", "S1", ] <- a_R_u_strA["H", "S1", ] - du_HS1
```

In a similar approach, we add the costs of transitioning from H to S1 and the cost of dying for strategy A.

```{r Add-IncCosts-Tr}
# Add transition cost due to transition from Healthy to Sick
a_R_c_strA["H", "S1", ] <- a_R_c_strA["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strA[-n_states, "D", ] <- a_R_c_strA[-n_states, "D", ] + ic_D
a_R_c_strA[, , 1]
```

Below, we show how to add the transition rewards to the reward matrices corresponding to SoC and strategies B and AB.

```{r Add-TransReward-UC}
## SoC
# Add disutility due to transition from H to S1
a_R_u_SoC["H", "S1", ] <- a_R_u_SoC["H", "S1", ] - du_HS1
# Add transition cost due to transition from H to S1
a_R_c_SoC["H", "S1", ] <- a_R_c_SoC["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_SoC[-n_states, "D", ] <- a_R_c_SoC[-n_states, "D", ] + ic_D

## Strategy B
# Add disutility due to transition from Healthy to Sick
a_R_u_strB["H", "S1", ] <- a_R_u_strB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strB["H", "S1", ] <- a_R_c_strB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strB[-n_states, "D", ] <- a_R_c_strB[-n_states, "D", ] + ic_D

## Strategy AB
# Add disutility due to transition from Healthy to Sick
a_R_u_strAB["H", "S1", ] <- a_R_u_strAB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strAB["H", "S1", ] <- a_R_c_strAB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strAB[-n_states, "D", ] <- a_R_c_strAB[-n_states, "D", ] + ic_D
```

The state and transition rewards are applied to the model dynamics by element-wise multiplication between $\mathbf{A}$ and $\mathbf{R}$, indicated by the $\odot$ sign, which produces the array of outputs for all $n_T$ cycles, $\mathbf{Y}$. Formally,
\begin{equation}
  \mathbf{Y} = \mathbf{A} \odot \mathbf{R}
  (\#eq:array-outputs)
\end{equation}

To obtain $\mathbf{Y}$ for QALYs and costs for all four strategies, we apply Equation \@ref(eq:array-outputs) by the element-wise multiplication of the transition array `a_A` by the corresponding array of rewards.

```{r Expected-Outcomes-Transitions-Cycle}
# For SoC
a_Y_c_SoC <- a_A * a_R_c_SoC
a_Y_u_SoC <- a_A * a_R_u_SoC
# For Strategy A
a_Y_c_strA <- a_A * a_R_c_strA
a_Y_u_strA <- a_A * a_R_u_strA
# For Strategy B
a_Y_c_strB <- a_A_trtB * a_R_c_strB
a_Y_u_strB <- a_A_trtB * a_R_u_strB
# For Strategy AB
a_Y_c_strAB <- a_A_trtB * a_R_c_strAB
a_Y_u_strAB <- a_A_trtB * a_R_u_strAB
```

The total rewards for each health state at cycle $t$, $\mathbf{y}_t$, is obtained by summing the rewards across all $j = 1,\ldots, n_S$ health states for all $n_T$ cycles.
\begin{equation}
  \mathbf{y}_t = \mathbf{1}^T Y_t = \left[\sum_{i=1}^{n_S}{Y_{[i,1,t]}}, \sum_{i=1}^{n_S}{Y_{[i,2,t]}}, \dots , \sum_{i=1}^{n_S}{Y_{[i,n_S,t]}}\right].
  (\#eq:exp-rewd-trans)
\end{equation}

To obtain the expected costs and QALYs per cycle for each strategy, $\mathbf{y}$, we apply Equation \@ref(eq:exp-rewd-trans) again across all the matrices of the third dimension of $\mathbf{Y}$ for all the outcomes.

```{r Expected-Outcomes-Cycle}
# Vectors of rewards
# QALYs under SoC
v_qaly_SoC <- rowSums(t(colSums(a_Y_u_SoC)))
# Costs under SoC
v_cost_SoC <- rowSums(t(colSums(a_Y_c_SoC)))
# QALYs under Strategy A
v_qaly_strA <- rowSums(t(colSums(a_Y_u_strA)))
# Costs under Strategy A
v_cost_strA <- rowSums(t(colSums(a_Y_c_strA)))
# QALYs under Strategy B
v_qaly_strB <- rowSums(t(colSums(a_Y_u_strB)))
# Costs under Strategy B
v_cost_strB <- rowSums(t(colSums(a_Y_c_strB)))
# QALYs under Strategy AB
v_qaly_strAB <- rowSums(t(colSums(a_Y_u_strAB)))
# Costs under Strategy AB
v_cost_strAB <- rowSums(t(colSums(a_Y_c_strAB)))
```

### Within-cycle correction and discounting future rewards
Following the accompanying tutorial,[@Alarid-Escudero2021a] here we use Simpson's 1/3rd rule as a WCC,[@Elbasha2016, @Elbasha2016a] and use exponential discounting for costs and QALYs. The within-cycle correction vector, $\mathbf{wcc}$, is the same for both costs and QALYs; thus, only one vector, `v_wcc`, is required.
```{r within-cycle-vector}
## Vector with cycles
v_cycles <- seq(1, n_cycles+1)
## Generate 2/3 and 4/3 multipliers for even and odd entries, respectively
v_wcc <- ((v_cycles %% 2)==0)*(2/3) + ((v_cycles %% 2)!=0)*(4/3)
## Substitute 1/3 in first and last entries
v_wcc[1] <- v_wcc[n_cycles + 1] <- 1/3
```

The discount vectors, $\mathbf{d}$, for costs and QALYs for the Sick-Sicker model, `v_dwc` and `v_dwe`, respectively, are 

```{r Discount vectors}
# Discount weight for effects
v_dwe <- 1 / ((1 + d_e) ^ (0:(n_cycles)))  
# Discount weight for costs 
v_dwc <- 1 / ((1 + d_c) ^ (0:(n_cycles)))    
```

To account for both discounting and within-cycle correction, we incorporate $\mathbf{wcc}$ in equation \@ref(eq:tot-exp-disc-rewd-wcc) using an element-wise multiplication with $\mathbf{d}$, indicated by the $\odot$ sign.
\begin{equation}
 y = \mathbf{y}^{'} \left(\mathbf{d} \odot \mathbf{wcc}\right).
 (\#eq:tot-exp-disc-rewd-wcc)
\end{equation}

The total expected discounted costs and QALYs under all four strategies accounting for within-cycle correction, $y$, is obtained by applying Equation \@ref(eq:tot-exp-disc-rewd-wcc) to the expected outcomes accounting for transition rewards.

```{r}
### For SoC
## QALYs
n_tot_qaly_SoC <- t(v_qaly_SoC) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_SoC <- t(v_cost_SoC) %*% (v_dwc * v_wcc)
### For Strategy A
## QALYs
n_tot_qaly_strA <- t(v_qaly_strA) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strA <- t(v_cost_strA) %*% (v_dwc * v_wcc)
### For Strategy B
## QALYs
n_tot_qaly_strB <- t(v_qaly_strB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strB <- t(v_cost_strB) %*% (v_dwc * v_wcc)
### For Strategy AB
## QALYs
n_tot_qaly_strAB <- t(v_qaly_strAB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strAB <- t(v_cost_strAB) %*% (v_dwc * v_wcc)
```

The total expected discounted QALYs and costs for the age-dependent Sick-Sicker model under the four strategies accounting for within-cycle correction are shown in Table \@ref(tab:Expected-outcomes-table). 

```{r Expected-outcomes, echo=FALSE, message=FALSE, warning=FALSE}
m_outcomes <- matrix(c(dollar(c(n_tot_cost_SoC, n_tot_cost_strA, 
                                n_tot_cost_strB, n_tot_cost_strAB)),
                       format(round(c(n_tot_qaly_SoC, n_tot_qaly_strA, 
                               n_tot_qaly_strB, n_tot_qaly_strAB), 3), nsmall = 3)),
                     ncol = 2, nrow = length(v_names_str), 
                     dimnames = list(v_names_str,
                                     c("Costs", "QALYs")))
```

```{r Expected-outcomes-table, echo=FALSE, message=FALSE, warning=FALSE}
kable(m_outcomes, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Total expected discounted QALYs and costs per average individual in the cohort of the age-dependent Sick-Sicker model by strategy accounting for within-cycle correction .", 
      align = c("l", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

# Cost-effectiveness analysis and incremental cost-effectiveness ratios (ICERs)
We combine the total expected discounted costs and QALYs for all four strategies into outcome-specific vectors, `v_cost_str` for costs and `v_qaly_str` for QALYs. We use the R package `dampack` (https://cran.r-project.org/web/packages/dampack/)[@Alarid-Escudero2021] to calculate the incremental costs and effectiveness and the incremental cost-effectiveness ratio (ICER) the non-dominated strategies and create the data frame `df_cea` with this information.

```{r CEA-analysis}
### Vector of costs
v_cost_str <- c(n_tot_cost_SoC, n_tot_cost_strA, n_tot_cost_strB, n_tot_cost_strAB)
### Vector of effectiveness
v_qaly_str <- c(n_tot_qaly_SoC, n_tot_qaly_strA, n_tot_qaly_strB, n_tot_qaly_strAB)

### Calculate incremental cost-effectiveness ratios (ICERs)
df_cea <- dampack::calculate_icers(cost = v_cost_str, 
                                   effect = v_qaly_str,
                                   strategies = v_names_str)
```

```{r CEA-table, echo=FALSE}
table_cea <- df_cea
## Format column names
colnames(table_cea)[2:6] <- c("Costs ($)", "QALYs", 
                              "Incremental Costs ($)", "Incremental QALYs", 
                              "ICER ($/QALY)") # name the columns
table_cea$`Costs ($)` <- comma(round(table_cea$`Costs ($)`, 0))
table_cea$`Incremental Costs ($)` <- comma(round(table_cea$`Incremental Costs ($)`, 0))
table_cea$QALYs <- round(table_cea$QALYs, 3)
table_cea$`Incremental QALYs` <- round(table_cea$`Incremental QALYs`, 3)
table_cea$`ICER ($/QALY)` <- comma(round(table_cea$`ICER ($/QALY)`, 0))
```

The results of the CEA of the age-dependent Sick-Sicker model are presented in Table \@ref(tab:table-cea). SoC is the least costly and effective strategy, followed by Strategy B producing an expected benefit of `r round(table_cea[2, 5], 3)` QALYs per individual for an additional expected cost of \$`r table_cea[2, 4]` with an ICER of \$`r table_cea[2, 6]`/QALY followed by Strategy AB with an ICER \$`r table_cea[3, 6]`/QALY. Strategy A is a dominated strategy. 
<!-- The total expected QALYs for SoC and strategies A, B and AB are `r round(n_tot_qaly_SoC, 3)`, `r round(n_tot_qaly_strA, 3)`, `r round(n_tot_qaly_strB, 3)` and `r round(n_tot_qaly_strAB, 3)`, respectively. The total expected costs for SoC and strategies A, B and AB are `r dollar(round(n_tot_cost_SoC, 0))`, `r dollar(round(n_tot_cost_strA, 0))`, `r dollar(round(n_tot_cost_strB, 0))` and `r dollar(round(n_tot_cost_strB, 0))`, respectively.  -->
  
```{r table-cea, echo=FALSE, message=FALSE, warning=FALSE}
kable(table_cea, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Cost-effectiveness analysis results for the age-dependent Sick-Sicker model. ND: Non-dominated strategy; D: Dominated strategy.",
      align = c("r", "c", "c", "c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")
```

Figure \@ref(fig:Sick-Sicker-CEA-AgeDep) shows the cost-effectiveness efficient frontier of all four strategies for the age-dependent Sick-Sicker model.

```{r Sick-Sicker-CEA-AgeDep, echo=FALSE, fig.cap='Cost-effectiveness efficient frontier of all four strategies for the age-dependent Sick-Sicker model.', message=FALSE, warning=FALSE, fig.pos="H"} 
plot(df_cea, label = "all", txtsize = 16) +
  expand_limits(x = c(NA, 21.8)) +
  theme(legend.position = c(0.8, 0.2))
```

# Probabilistic sensitivity analysis
To quantify the effect of model parameter uncertainty on cost-effectiveness outcomes, we conducted a probabilistic sensitivity analysis (PSA).[@Briggs2012] In a PSA, we randomly draw parameter sets from distributions that reflect the current uncertainty in model parameter estimates. The distribution for all the parameters and their values are described in Table and in more detailed in the Supplementary Material. For each sampled set of parameter values, we compute model outcomes (e.g., total discounted cost and QALYs) for each strategy. In a previously published manuscript, we describe the implementation of these steps in R.[@Alarid-Escudero2019e] Briefly, to conduct the PSA, we create three R functions, which are provided in the supplementary material and in the accompanying GitHub repository:
  
```{r PSA-setup, eval=TRUE, echo=FALSE}
# Number of PSA samples
n_sim <- 1000
# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)

# Initialize matrices with PSA output 
# data.frame for costs
df_c <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_c) <- v_names_str
# data.frame for effectiveness
df_e <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_e) <- v_names_str
```


1. A function called `generate_psa_params(n_sim, seed)` that generates a sample of size `n_sim` for the model parameters from their distributions defined in Table \@ref(tab:param-table), the function also takes a seed number as input, which ensures reproducibility of the PSA results. By calling this function, we generate the sample of parameter sets for the PSA: `df_psa_input <- generate_psa_params(n_sim = n_sim)`
2. A function called `decision_model` that wraps the R code of the age-dependent cSTM described in section [Simulation-time dependency](#simulation-time-dependency) and requires as input a list of model parameter values.
3. A function called `calculate_ce_out` that calculates outcomes of interest (e.g., total discounted costs and QALYs) based on the `decision_model` function output.

```{r PSA-run, eval=TRUE, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE}
## Conduct probabilistic sensitivity analysis
# Run Markov model on each parameter set of PSA input dataset
for(i in 1:n_sim){
  l_out_temp <- calculate_ce_out(l_params_all = df_psa_input[i, ])
  df_c[i, ]  <- l_out_temp$Cost  
  df_e[i, ]  <- l_out_temp$Effect
  # Display simulation progress
  # if(i/(n_sim/100) == round(i/(n_sim/100), 0)) { # display progress every 5%
  #   cat('\r', paste(i/n_sim * 100, "% done", sep = " "))
  # }
}
```

```{r Generate-PSA-object, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
# Create PSA object for dampack
l_psa <- make_psa_obj(cost          = df_c, 
                      effectiveness = df_e, 
                      parameters    = df_psa_input, 
                      strategies    = v_names_str)
l_psa$strategies <- v_names_str
colnames(l_psa$effectiveness)<- v_names_str
colnames(l_psa$cost)<- v_names_str

# Vector with willingness-to-pay (WTP) thresholds.
v_wtp <- seq(0, 200000, by = 5000)

## Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF)
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
ceac_obj$Strategy <- ordered(ceac_obj$Strategy, v_names_str)

##  Expected Loss Curves (ELCs)
elc_obj <- calc_exp_loss(wtp = v_wtp, psa = l_psa)
```

To conduct the PSA of the CEA using the time-independent Sick-Sicker cSTM, we sampled `r comma(n_sim)` parameter sets for all the parameters from the distributions defined in Table \@ref(tab:). For each sampled parameter set, we simulated each strategy. Results from a PSA can be represented in various ways. For example, the joint distribution, 95% confidence ellipse, and the expected values of the total discounted costs and QALYs for each strategy can be plotted in a cost-effectiveness (CE) scatter plot ( Figure \@ref(fig:CE-scatter-TimeDep)),[@Briggs2002] where each of the `r comma(n_sim)` simulations are plotted as a point in the graph. The CE scatter plot for CEA using the time-independent model shows that strategy AB has the highest expected costs and QALYs. Standard of care has the lowest expected cost and QALYs. Strategy B is more effective and least costly than Strategy A. Strategy A is a strongly dominated strategy.

```{r CE-scatter-TimeDep, echo=FALSE, fig.cap='Cost-effectiveness scatter plot.', message=FALSE, warning=FALSE, fig.pos="H"} 
# CEAC & CEAF plot
plot(l_psa, txtsize = 16) +
  xlab("Effectiveness (QALYs)") +
  guides(col = guide_legend(nrow = 2)) +
  theme(legend.position = "bottom")
```

In Figure \@ref(fig:CEAC-AgeDep), we present the cost-effectiveness acceptability curves (CEACs), which shows the probability that each strategy is cost-effective, and the cost-effectiveness frontier (CEAF) which shows the strategy with the highest expected monetary benefit, over a range of willingness-to-pay (WTP) thresholds. The net monetary benefit for each strategy is defined as the product of total discounted QALYs and the WTP threshold minus the total discounted costs, calculated for each PSA parameter set sample. At WTP thresholds less than \$65,000 per QALY, SoC is the strategy with the highest probability of being cost-effective and the highest expected net monetary benefit. Strategy B has the highest probability of being cost-effective and the highest expected net monetary benefit for WTP thresholds between \$65,000 and \$100,000 per QALY. Strategy AB, has the highest expected net monetary benefit for WTP thresholds greater than or equal to \$100,000 per QALY and is the strategy with the highest probability of being cost-effective.

```{r CEAC-AgeDep, echo=FALSE, fig.cap='Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF).', message=FALSE, warning=FALSE, fig.pos="H"} 
# CEAC & CEAF plot
plot(ceac_obj, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14) +
  theme(legend.position = c(0.8, 0.5))
```

The code provided in the GitHub repository also produces expected loss curves (ELCs). These curves quantify the expected loss from each strategy over a range of WTP thresholds (Figure \@ref(fig:ELC-AgeDep)). The expected loss considers both the probability of making the wrong decision and the magnitude of the loss due to this decision, representing the foregone benefits of choosing a suboptimal strategy. The expected loss of the optimal strategy represents the lowest envelope of the ELCs because, given current information, the loss cannot be minimized further. The lower envelope also represents the expected value of perfect information (EVPI), which quantifies the value of eliminating parameter uncertainty. The strategy SoC has the lowest expected loss for WTP thresholds less than `r dollar(max(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Standard of care"), "WTP"]), accuracy = 1)` per QALY, strategy B has the lowest expected loss for WTP threshold greater than or equal to `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy B"), "WTP"]), accuracy = 1)` and less than `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy AB"), "WTP"]), accuracy = 1)`. Strategy AB has the lowest expected loss for WTP threshold greater than or equal to `r dollar(min(subset(elc_obj, On_Frontier == TRUE)[which(subset(elc_obj, On_Frontier == TRUE)$Strategy=="Strategy AB"), "WTP"]), accuracy = 1)` per QALY. At a WTP threshold of `r dollar(subset(elc_obj, On_Frontier == TRUE)[which.max(subset(elc_obj, On_Frontier == TRUE)$Expected_Loss), "WTP"], accuracy = 1)` per QALY, the EVPI is highest at `r dollar(subset(elc_obj, On_Frontier == TRUE)[which.max(subset(elc_obj, On_Frontier == TRUE)$Expected_Loss), "Expected_Loss"], accuracy = 1)`. For a more detailed description of these outputs and the R code to generate them, we refer the reader to a previous publication by our group.[@Alarid-Escudero2019]

```{r ELC-AgeDep, echo=FALSE, fig.cap='Expected loss curves (ELCs) and expected value of perfect information (EVPI).', message=FALSE, warning=FALSE, fig.pos="H"} 
# ELC plot
plot(elc_obj, log_y = FALSE, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14,
     col = "full") +
  # geom_point(aes(shape = as.name("Strategy"))) +
  scale_y_continuous("Expected Loss (Thousand $)", 
                     breaks = number_ticks(10),
                     labels = function(x) x/1000) +
  theme(legend.position = c(0.4, 0.7))
```
  
# Discussion
In this tutorial, we provided a conceptualization of various types of cSTMs with their mathematical description and a walk-through of their implementation for CEA in R using a previously published example. We used R as the programming language of choice to show the implementation of these models with accompanying code throughout the tutorial. We describe both time-independent and time-dependent models. We showed two different implementations of the time-dependent model, accounting for transition probabilities that are dependent on simulation time (e.g., age-dependence) and those that are dependent on state-residence.  

There are several alternative approaches to incorporate time-dependency in cSTMs in R and various programming languages. For example, another approach to incorporate age-dependency involves updating the time-varying elements of the transition probability matrix $P_t$ at each time point $t$. That would alleviate the need for the construction of the array `a_P`. This can reduce computer memory requirements but at the expense of increasing the number of operations in the update of $P_t$ at every cycle. Another approach to account for history dependence is to use a 3-dimensional transition probability matrix with dimensions for the current state, future state, and time in the current state.[@Hawkins2005] However, to incorporate age-dependence, this multidimensional matrix will have to be expanded by another dimension. The states will have to be replicated for as many age groups are considered in the model. In this tutorial, we decided to use the third dimension as the cohort's age and incorporate state-residence by expanding the corresponding health states on the second dimension of the 3-dimensional array to account for time spent in the current state. This approach's benefit is that we can still the transition dynamics array to capture all transitions between all states for all cycles.

The parameterization of our example model assumes all parameters are known or at least, the characterization of their uncertainty is known (i.e., we know their distributions). However, to construct a real-world cSTM it is important that modelers conduct a thorough synthesis of current evidence to determine the appropriate structure of these models and inform all parameters. For example, determining whether transitions between non-death health states are estimated conditional on being alive or mortality risks are also considered competing risks.[@Briggs2012] Similarly, our PSA analysis is a simplification of reality where all model parameters are assumed to be independent from each other. However, parameters could be correlated with each other or have a rank ordering, and appropriate statistical methods that simulate these correlations or rank ordering might be needed.[@Goldhaber-Fiebert2015] We encourage modelers to use appropriate statistical methods to accurately synthesize and quantify model parameters uncertainty. In addition, all model parameters should be correctly specified for the cycle length of the model. For example, some probability revision is required to correctly adjust an annual mortality rate to a weekly probability.[@Hunink2014]

In general, cSTMs are recommended when the number of states is "not too large".[@Siebert2012c] This recommendation arises because as the number of states increases, it becomes more difficult to keep track of their construction but not because of the added computational expense. It is possible to build fairly complex cSTMs in R as long as the size of the transition probability matrix and outputs of interest can be stored in the RAM memory of the computer running the analysis. For example, a typical PC with 8GB of RAM can handle a transition probability array of about 1000 states and 600 slices. However, these matrices can grow quickly, and if the required number of state descriptions gets too large and difficult to manage its coding, it becomes preferable to use a stochastic (Monte Carlo) version of the state-transition model --often called individual-based state-transition models (iSTM) or microsimulation models-- rather than a cohort simulation model.[@Siebert2012c]  In iSTM, the risks and rewards of simulated individuals do not need to depend only on a specific health state and can depend on their individual characteristics and attributes. Besides, modelers can store health state history and other events over time for each individual to determine the risk of new events and corresponding costs and effects. It is recommended to think about the required model structure before implementing the model in R or any other tool because turning a cSTM into an iSTM requires a different code structure. However, most input parameters and some model structures might remain the same. Still, an iSTM will also require additional functions to describe the dependency of transition probabilities and rewards on individuals' history. In a previous tutorial, we showed how to write these additional functions for the Sick-Sicker example model.[@Krijkamp2018]

With increasing model complexity and the use of functions for PSA, it is important to ensure all code and functions work as expected and all elements of cSTM are valid. This can be achieved by functions that help with model debugging and validation and through unit testing. In the accompanying GitHub repository, we provided functions to check that transition probability matrices and their elements are valid. However, unit testing is beyond the scope of this tutorial but we refer the reader to a previously published manuscript where we describe unit testing in more detail and provide accompanying code.[@Alarid-Escudero2019e]

We focused on discrete-time matrix-form cSTMs but these can also be implemented via a set of difference equations and in continuous time using differential equatiopns in R.[@Grimmett2014; @Axler2005]  We refer readers interested in learning more on continuous-time cSTMs to previously published manuscripts[@Cao2016;@VanRosmalen2013;@Begun2013;@Soares2012] and a tutorial using R.[@Frederix2013a] There are other approaches to construct Markov models in R, most of them through purpose-specific R packages. For example, the `heemod`[@Filipovic-Pierucci2017] package is designed to build Markov models that account for dependency using a pre-defined structure. Although `heemod` is a well-structured package, it requires users to set up the structure of the Markov model, specify the parameters and run analyses in a pre-specified approach. This, however, limits the understanding on how cSTMs and Markov models work and are constructed. In this tutorial, we show how cSTMs are constructed, parameterized and run by using only base R so readers get a deep understanding of this type of decision models. Finally, the variable names used in this paper reflect our own style. While we provide guidance on standardized variable names, the adoption of these conventions are ultimately a personal preference. 

In summary, this tutorial provides a conceptualization of cSTMs and a step-by-step guide to implement them in R. We aim to add to the current body of literature and material on building this type of decision models so health decision scientists and health economists are able to develop cSTMs in a more flexible, efficient, open-source manner, and encouraging increased transparency and reproducibility.

# Acknowledgements
Dr Alarid-Escudero was supported by a grant from the National Cancer Institute (U01-CA-199335) as part of the Cancer Intervention and Surveillance Modeling Network (CISNET), and the Gordon and Betty Moore Foundation. Miss Krijkamp was supported by the Society for Medical Decision Making (SMDM) fellowship through a grant by the Gordon and Betty Moore Foundation (GBMF7853). Dr Enns was supported by a grant from the National Institute of Allergy and Infectious Diseases of the National Institutes of Health under award no. K25AI118476. Dr Hunink receives Royalties from Cambridge University Press for a textbook on Medical Decision Making, reimbursement of expenses from the European Society of Radiology (ESR) for work on the ESR guidelines for imaging referrals, reimbursement of expenses from the European Institute for Biomedical Imaging Research (EIBIR) for membership of the Scientific Advisory Board, and research funding from the American Diabetes Association, the Netherlands Organization for Health Research and Development, the German Innovation Fund, Netherlands Educational Grant ("Studie Voorschot Middelen"), and the Gordon and Betty Moore Foundation. Dr Jalal was supported by a grant from the National Institute on Drug Abuse of the National Institute of Health under award no. K01DA048985. The content is solely the responsibility of the authors and does not necessarily represent the official views of the National Institutes of Health. The funding agencies had no role in the design of the study, interpretation of results, or writing of the manuscript. The funding agreement ensured the authors’ independence in designing the study, interpreting the data, writing, and publishing the report. We also want to thank the anonymous reviewers of *Medical Decision Making* for their valuable suggestions and the students that took our classes to try our our materials.

# References

