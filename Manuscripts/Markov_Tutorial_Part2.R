## ---- echo = FALSE-----------------------------------------------------------------------------------------------
## Journal Abbreviations
# library(RJSONIO)
# if(!file.exists("abbreviations.json")){
# download.file("https://ndownloader.figshare.com/files/5212423","wos_abbrev_table.csv")
#   abbrev <- read.csv("wos_abbrev_table.csv", sep = ";", header = TRUE, stringsAsFactors = FALSE)
#   abbrev$full <- gsub("\\", "\\\\",abbrev$full, fixed = TRUE)
#   abbrev.list <- list('default' = list('container-title' = abbrev$abbrev.dots))
#   names(abbrev.list$default$`container-title`) = abbrev$full
#   write(toJSON(abbrev.list), "abbreviations.json")
#   rm(abbrev)
#   rm(abbrev.list)
# }


## ----setup, include=FALSE----------------------------------------------------------------------------------------
#install.packages(c("kableExtra", "scales", "tensorA" ))
library(knitr)
library(kableExtra) # https://haozhu233.github.io/kableExtra/awesome_table_in_html.html
library(dplyr)
library(reshape2)
library(ggplot2)
library(scales) # For dollar signs and commas
library(boot)
# devtools::install_github("DARTH-git/dampack")
library(dampack)
# devtools::install_github("DARTH-git/darthtools")
library(darthtools)
knitr::opts_chunk$set(echo = TRUE)
doc_type <- knitr::opts_knit$get('rmarkdown.pandoc.to')

# Load customed  functions
source("../Manuscript/functions/Functions.R")


# Define parameters
cycle_length <- 1  # cycle length equal one year
n_age_init <- 25   # age at baseline
n_age_max  <- 100  # maximum age of follow up
n_cycles <- n_age_max - n_age_init # time horizon, number of cycles
# v_r_mort_by_age <- seq(0.001, 0.01, length.out = 100)
lt_usa_2005 <- read.csv("../data/LifeTable_USA_Mx_2015.csv")
v_r_mort_by_age <- lt_usa_2005 %>% 
  # filter(Age >= age & Age <= n_age_max) %>%
  select(Total) %>%
  as.matrix()

## General setup
v_names_states <- c("H", "S1", "S2", "D") # the 4 health states of the model:
                               # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
n_states <- length(v_names_states) # number of health states 
d_c <- d_e <- 0.03 # equal discount of costs and QALYs by 3%
v_names_str <- c("Standard of care", # store the strategy names
                 "Strategy A", 
                 "Strategy B",
                 "Strategy AB") 
n_str <- length(v_names_str)

## Transition probabilities (per cycle)
r_HD    <- 0.002 # constant rate of dying when Healthy (all-cause mortality rate)
p_HS1   <- 0.15  # probability of becoming Sick when Healthy
p_S1H   <- 0.5   # probability of becoming Healthy when Sick
p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy 

# Effectiveness of treatment B
hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B

## Transition probability of becoming Sicker when Sick for treatment B
# transform probability to rate
r_S1S2      <- -log(1-p_S1S2)
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when Sick for treatment B
r_S1S2_trtB <- r_S1S2 * hr_S1S2_trtB
# transform rate to probability
p_S1S2_trtB <- 1-exp(-r_S1S2_trtB*cycle_length) # probability to become Sicker when Sick 
                                                 # under treatment B conditional on surviving

## Cost and utility inputs 
# State rewards
c_H   <- 2000  # cost of being Healthy for one cycle 
c_S1  <- 4000  # cost of being Sick for one cycle 
c_S2  <- 15000 # cost of being Sicker for one cycle
c_D   <- 0     # cost of being dead for one cycle
c_trtA <- 12000 # cost of treatment A for one cycle 
c_trtB <- 13000 # cost of treatment B for one cycle

u_H   <- 1     # utility of being Healthy for one cycle 
u_S1  <- 0.75  # utility of being Sick for one cycle 
u_S2  <- 0.5   # utility of being Sicker for one cycle
u_D   <- 0     # utility of being dead for one cycle
u_trtA <- 0.95  # utility when being treated for one cycle

# Transition rewards
du_HS1 <- 0.01  # disutility when transitioning from Healthy to Sick
ic_HS1 <- 1000  # increase in cost when transitioning from Healthy to Sick
ic_D   <- 2000  # increase in cost when dying

# PSA parameters
n_sim <- 1000 # Number of PSA samples


## ----figure-setup, echo=FALSE, include=FALSE---------------------------------------------------------------------
## chunk will ensure that:
library(formatR)
# indent = 2: two spaces of indentation.
# tidy=TRUE puts formatR to work to produce a beautiful and standardized layout code.
if(!knitr:::is_html_output())
{
  # options("width"=56)
  knitr::opts_chunk$set(tidy.opts=list(indent = 1.5)) # width.cutoff=56, tidy = TRUE
  knitr::opts_chunk$set(fig.pos = 'H')
}

## chunk will ensure that:
# all the figures generated by the report will be placed in the figs/sub-directory
# all the figures will be 6.5 x 4 inches and centered in the text.
knitr::opts_chunk$set(fig.path="../figs/", fig.width=8, fig.height=6, fig.align="center")


## ----STD-Sick-Sicker, echo=FALSE, fig.cap="State-transition diagram of the time-independent Sick-Sicker cohort state-transition model with the name of the health states and possible transitions with their corresponding transition probabilities.", fig.pos="H"----
knitr::include_graphics("../figs/Sick-Sicker.png") 


## ----Model-Params, eval=FALSE------------------------------------------------------------------------------------
## ## General setup
## cycle_length <- 1 # cycle length equal one year
## n_age_init <- 25  # age at baseline
## n_age_max  <- 100 # maximum age of follow up
## n_cycles <- n_age_max - n_age_init # number of cycles
## v_names_states <- c("H", "S1", "S2", "D") # the 4 health states of the model:
##                                # Healthy (H), Sick (S1), Sicker (S2), Dead (D)
## n_states <- length(v_names_states) # number of health states
## d_e <- 0.03 # discount rate for QALYs of 3% per cycle
## d_c <- 0.03 # discount rate for costs of 3% per cycle
## v_names_str <- c("Standard of care", # store the strategy names
##                  "Strategy A",
##                  "Strategy B",
##                  "Strategy AB")
## 
## ## Transition probabilities (per cycle), hazard ratios and odds ratio (OR)
## r_HD    <- 0.002 # constant rate of dying when Healthy (all-cause mortality rate)
## p_HS1   <- 0.15  # probability of becoming Sick when Healthy
## p_S1H   <- 0.5   # probability of becoming Healthy when Sick
## p_S1S2  <- 0.105 # probability of becoming Sicker when Sick
## hr_S1   <- 3     # hazard ratio of death in Sick vs Healthy
## hr_S2   <- 10    # hazard ratio of death in Sicker vs Healthy
## 
## # Effectiveness of treatment B
## hr_S1S2_trtB <- 0.6 # hazard ratio of becoming Sicker when Sick under treatment B
## 
## ## State rewards
## ## Costs
## c_H    <- 2000  # cost of being Healthy for one cycle
## c_S1   <- 4000  # cost of being Sick for one cycle
## c_S2   <- 15000 # cost of being Sicker for one cycle
## c_D    <- 0     # cost of being dead for one cycle
## c_trtA <- 12000 # cost of receiving treatment A for one cycle
## c_trtB <- 13000 # cost of receiving treatment B for one cycle
## # Utilities
## u_H    <- 1     # utility of being Healthy for one cycle
## u_S1   <- 0.75  # utility of being Sick for one cycle
## u_S2   <- 0.5   # utility of being Sicker for one cycle
## u_D    <- 0     # utility of being dead for one cycle
## u_trtA <- 0.95  # utility when receiving treatment A for one cycle
## 
## ## Transition rewards
## du_HS1 <- 0.01  # one-time utility decrement when transitioning from Healthy to Sick
## ic_HS1 <- 1000  # one-time cost when transitioning from Healthy to Sick
## ic_D   <- 2000  # one-time cost when dying


## ----Sick-Sicker-Params, eval=TRUE-------------------------------------------------------------------------------
## Mortality rates
r_S1D <- r_HD * hr_S1 # rate of dying when Sick
r_S2D <- r_HD * hr_S2 # rate of dying when Sicker
## Probabilities of dying
cycle_length <- 1
p_HD  <- 1 - exp(-r_HD*cycle_length)  # all.cause mortaility risk (i.e., probability)
p_S1D <- 1 - exp(-r_S1D*cycle_length) # probability of dying when Sick
p_S2D <- 1 - exp(-r_S2D*cycle_length) # probability of dying when Sicker


## ----New-Treatment-2-Effectiveness, eval=TRUE--------------------------------------------------------------------
## Transition probability of becoming Sicker when Sick for treatment B
# transform probability to rate
r_S1S2 <- -log(1-p_S1S2)/cycle_length
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when Sick 
# for treatment B
r_S1S2_trtB <- r_S1S2 * hr_S1S2_trtB
# transform rate to probability
p_S1S2_trtB <- 1-exp(-r_S1S2_trtB*cycle_length) # probability to become Sicker when Sick 
                                                # under treatment B conditional on surviving


## ----Sick-Sicker-s0----------------------------------------------------------------------------------------------
v_s_init <- c(H = 1, S1 = 0, S2 = 0, D = 0) # initial state vector
v_s_init


## ----Sick-Sicker-M-----------------------------------------------------------------------------------------------
## Initialize cohort trace for SoC
m_M <- matrix(NA, 
              nrow = (n_cycles + 1), ncol = n_states, 
              dimnames = list(0:n_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M[1, ] <- v_s_init
## Initialize cohort trace under treatment B
m_M_trtB <- m_M # structure and initial states remain the same.


## ----Sick-Sicker-P2----------------------------------------------------------------------------------------------
## Initialize transition probability matrix
m_P <- matrix(0, 
              nrow = n_states, ncol = n_states, 
              dimnames = list(v_names_states, v_names_states)) # define row and column names
## Fill in matrix
# From H
m_P["H", "H"]   <- (1 - p_HD) * (1 - p_HS1)
m_P["H", "S1"]  <- (1 - p_HD) * p_HS1
m_P["H", "D"]   <- p_HD
# From S1
m_P["S1", "H"]  <- (1 - p_S1D) * p_S1H
m_P["S1", "S1"] <- (1 - p_S1D) * (1 - (p_S1H + p_S1S2))
m_P["S1", "S2"] <- (1 - p_S1D) * p_S1S2
m_P["S1", "D"]  <- p_S1D
# From S2
m_P["S2", "S2"] <- 1 - p_S2D
m_P["S2", "D"]  <- p_S2D
# From D
m_P["D", "D"]   <- 1


## ----Sick-Sicker-Time-independent-New-Treatment2-----------------------------------------------------------------
## Initialize transition probability matrix for treatment B
m_P_trtB <- m_P
## Update only transition probabilities from S1 involving p_S1S2
m_P_trtB["S1", "S1"] <- (1 - p_S1D) * (1 - (p_S1H + p_S1S2_trtB))
m_P_trtB["S1", "S2"] <- (1 - p_S1D) * p_S1S2_trtB


## ----------------------------------------------------------------------------------------------------------------
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(m_P)
check_transition_probability(m_P_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(m_P,      n_states = n_states, n_cycles = n_cycles)
check_sum_of_transition_array(m_P_trtB, n_states = n_states, n_cycles = n_cycles)


## ----Sick-Sicker-TimeHomogeneous-Solution------------------------------------------------------------------------
# Iterative solution of time-independent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M[t + 1, ] <- m_M[t, ] %*% m_P
  # For treatment B
  m_M_trtB[t + 1, ] <- m_M_trtB[t, ] %*% m_P_trtB
}


## ----Trace, echo=FALSE, message=FALSE, warning=FALSE-------------------------------------------------------------
kable(head(round(cbind(Cycle = as.numeric(rownames(m_M)), m_M), 3)), 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      row.names = FALSE,
      booktabs = TRUE,
      caption = "The distribution of the cohort  under SoC for the first six cycles of the time-independent Sick-Sicker model. The first row, labeled with cycle 0, contains the distribution of the cohort at time zero.",
      align = c("c", "c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")


## ----Sick-Sicker-Trace-TimeHom, echo=FALSE, fig.cap='Cohort trace of the time-independent cSTM', message=FALSE, warning=FALSE, fig.pos="H"----
cols <- get_DARTH_cols()
lty <-  c("H" = 1, "S1" = 2, "S2" = 4, "D" = 3)
ggplot(melt(m_M), aes(x = Var1, y = value, 
                      color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_colour_manual(name = "Health state", 
                     values = cols) +
  scale_linetype_manual(name = "Health state",
                        values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom",#c(0.7, 0.75), 
        legend.background = element_rect(fill = NA))


## ----------------------------------------------------------------------------------------------------------------
# Age-specific mortality rate in the Healthy state (background mortality)
v_r_HDage <- v_r_mort_by_age[(n_age_init + 1) + 0:(n_cycles - 1)]
# Transform to age-specific background mortality risk
v_p_HDage  <- 1 - exp(-v_r_HDage) 


## ----------------------------------------------------------------------------------------------------------------
## Age-specific mortality rates in the Sick and Sicker states
v_r_S1Dage <- v_r_HDage * hr_S1 # when Sick
v_r_S2Dage <- v_r_HDage * hr_S2 # when Sicker
## Age-specific probabilities of dying in the Sick and Sicker states
v_p_S1Dage <- 1 - exp(-v_r_S1Dage) # when Sick
v_p_S2Dage <- 1 - exp(-v_r_S2Dage) # when Sicker


## ----Array-Time-Dependent, echo=FALSE, out.width='100%', fig.cap="A 3-dimensional representation of the transition probability array of the age-dependent Sick-Sicker model with simulation-time dependency.",fig.pos="H"----
knitr::include_graphics("../figs/3D-state-transition-array-sick-sicker-without-tunnels.png")


## ----Init-Sick-Sicker-TimeDep-P----------------------------------------------------------------------------------
# Initialize the transition probability array
a_P <- array(0, dim = c(n_states, n_states, n_cycles),
              dimnames = list(v_names_states, v_names_states, 0:(n_cycles - 1)))


## ----Sick-Sicker-TimeDep-P---------------------------------------------------------------------------------------
### Fill in array
## From H
a_P["H", "H", ]   <- (1 - v_p_HDage) * (1 - p_HS1)
a_P["H", "S1", ]  <- (1 - v_p_HDage) * p_HS1
a_P["H", "D", ]   <- v_p_HDage
## From S1
a_P["S1", "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2))
a_P["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2
a_P["S1", "D", ]  <- v_p_S1Dage
## From S2
a_P["S2", "S2", ] <- 1 - v_p_S2Dage
a_P["S2", "D", ]  <- v_p_S2Dage
## From D
a_P["D", "D", ]   <- 1


## ----Transition-Probability-Array-1------------------------------------------------------------------------------
a_P[, , 1]


## ----Sick-Sicker-Time-Dependent-Age-New-Treatment2---------------------------------------------------------------
## Initialize transition probability array for treatment B
a_P_trtB <- a_P
## Update only transition probabilities from S1 involving p_S1S2
a_P_trtB["S1", "S1", ] <- (1 - v_p_S1Dage) * (1 - (p_S1H + p_S1S2_trtB))
a_P_trtB["S1", "S2", ] <- (1 - v_p_S1Dage) * p_S1S2_trtB


## ----------------------------------------------------------------------------------------------------------------
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P)
check_transition_probability(a_P_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P,      n_states = n_states, n_cycles = n_cycles)
check_sum_of_transition_array(a_P_trtB, n_states = n_states, n_cycles = n_cycles)


## ----Init-Sick-Sicker-TimeDependent-Trace------------------------------------------------------------------------
## Initialize cohort trace for age-dependent (ad) cSTM under SoC
m_M_ad <- matrix(NA, 
                 nrow = (n_cycles + 1), ncol = n_states, 
                 dimnames = list(0:n_cycles, v_names_states))
# Store the initial state vector in the first row of the cohort trace
m_M_ad[1, ] <- v_s_init
## Initialize cohort trace under treatment B
m_M_ad_trtB <- m_M_ad # structure and initial states remain the same.


## ----Sick-Sicker-TimeDependent-Solution--------------------------------------------------------------------------
# Iterative solution of age-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_ad[t + 1, ] <- m_M_ad[t, ] %*% a_P[, , t]
  # For treatment B
  m_M_ad_trtB[t + 1, ] <- m_M_ad_trtB[t, ] %*% a_P_trtB[, , t]
}


## ----Sick-Sicker-Trace-TimeDep, echo=FALSE, fig.cap='Cohort trace of the age-dependent cSTM under SoC.', message=FALSE, warning=FALSE, fig.pos="H"----
ggplot(melt(m_M_ad), aes(x = Var1, y = value, 
                         color = Var2, linetype = Var2)) +
  geom_line(size = 1) +
  scale_color_manual(name = "Health state", values = cols) +
  scale_linetype_manual(name = "Health state", values = lty) +
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion of the cohort") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom", 
        legend.background = element_rect(fill = NA))


## ----STD-Sick-Sicker-tunnels, echo=FALSE, out.width='100%', fig.cap="State-transition diagram of the Sick-Sicker model with tunnel states expanding the Sick state ($S1_1, S1_2,...,S1_{n_{tunnels}}$).", fig.pos="H"----
knitr::include_graphics("../figs/Sick-Sicker-with-tunnels.png")


## ----------------------------------------------------------------------------------------------------------------
## Number of tunnels
n_tunnel_size <- n_cycles 
## Name for tunnel states of Sick state
v_Sick_tunnel <- paste("S1_", seq(1, n_tunnel_size), "Yr", sep = "")
## Create variables for model with tunnels
v_names_states_tunnels <- c("H", v_Sick_tunnel, "S2", "D") # state names
n_states_tunnels <- length(v_names_states_tunnels)         # number of states
## Initialize first cycle of Markov trace accounting for the tunnels
v_s_init_tunnels <- c(1, rep(0, n_tunnel_size), 0, 0) 


## ----------------------------------------------------------------------------------------------------------------
# Weibull parameters
p_S1S2_lambda <- 0.08 # scale
p_S1S2_gamma  <- 1.1  # shape
# Weibull function
v_p_S1S2_tunnels <- p_S1S2_lambda * p_S1S2_gamma *
  (1:n_tunnel_size)^{p_S1S2_gamma-1}


## ----Init-Sick-Sicker-TimeDep-P-tunnels--------------------------------------------------------------------------
# Initialize array
a_P_tunnels <- array(0, dim = c(n_states_tunnels, n_states_tunnels, n_cycles),
                     dimnames = list(v_names_states_tunnels, 
                                     v_names_states_tunnels, 
                                     0:(n_cycles - 1)))


## ----Array-Time-Dependent-Tunnels, echo=FALSE, out.width='100%', fig.cap="The 3-dimensional transition probability array of the Sick-Sicker model expanded to account for age-dependence and S1 state-residence using tunnel states.", fig.pos="H"----
knitr::include_graphics("../figs/3D-state-transition-array-sick-sicker-tunnels.png")


## ----Sick-Sicker-TimeDep-P-tunnels-------------------------------------------------------------------------------
### Fill in array
## From H
a_P_tunnels["H", "H", ]              <- (1 - v_p_HDage) * (1 - p_HS1)
a_P_tunnels["H", v_Sick_tunnel[1], ] <- (1 - v_p_HDage) * p_HS1
a_P_tunnels["H", "D", ]              <- v_p_HDage
## From S1
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels[v_Sick_tunnel[i], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ]   <- (1 - v_p_S1Dage) *
                                           (1 - (p_S1H + v_p_S1S2_tunnels[i]))
  a_P_tunnels[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels[i]
  a_P_tunnels[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# Repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "H", ]  <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) *
                                               (1 - (p_S1H + v_p_S1S2_tunnels[n_tunnel_size]))
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) * 
                                                     v_p_S1S2_tunnels[n_tunnel_size]
a_P_tunnels[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage
### From S2
a_P_tunnels["S2", "S2", ] <- 1 - v_p_S2Dage
a_P_tunnels["S2", "D", ]  <- v_p_S2Dage
# From D
a_P_tunnels["D", "D", ] <- 1


## ----------------------------------------------------------------------------------------------------------------
## Transform risk of progression from Sick to Sicker to a rate
# vector of rates of becoming Sicker when Sick
v_r_S1S2_tunnels <- -log(1-v_p_S1S2_tunnels)/cycle_length
# apply hazard ratio to rate to obtain transition rate of becoming Sicker when 
#cSick for treatment B
r_S1S2_tunnels_trtB <- v_r_S1S2_tunnels * hr_S1S2_trtB
# transform rate to probability to become Sicker when Sick under treatment B 
# conditional on surviving
v_p_S1S2_tunnels_trtB <- 1-exp(-r_S1S2_tunnels_trtB*cycle_length) 


## ----Sick-Sicker-Time-Dependent-State-Residence-New-Treatment2---------------------------------------------------
## Initialize transition probability array for treatment B
a_P_tunnels_trtB <- a_P_tunnels
## Update only transition probabilities from S1 involving v_p_S1S2_tunnels
for(i in 1:(n_tunnel_size - 1)){
  a_P_tunnels_trtB[v_Sick_tunnel[i], "H", ] <- (1 - v_p_S1Dage) * p_S1H
  a_P_tunnels_trtB[v_Sick_tunnel[i], 
              v_Sick_tunnel[i + 1], ] <- (1 - v_p_S1Dage) * 
                                         (1 - (p_S1H + v_p_S1S2_tunnels_trtB[i]))
  a_P_tunnels_trtB[v_Sick_tunnel[i], "S2", ] <- (1 - v_p_S1Dage) * v_p_S1S2_tunnels_trtB[i]
  a_P_tunnels_trtB[v_Sick_tunnel[i], "D", ]  <- v_p_S1Dage
}
# repeat code for the last cycle to force the cohort stay in the last tunnel state of Sick
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "H", ] <- (1 - v_p_S1Dage) * p_S1H
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size],
            v_Sick_tunnel[n_tunnel_size], ] <- (1 - v_p_S1Dage) * 
                                               (1 - (p_S1H +v_p_S1S2_tunnels_trtB[n_tunnel_size]))
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "S2", ] <- (1 - v_p_S1Dage) *
                                                           v_p_S1S2_tunnels_trtB[n_tunnel_size]
a_P_tunnels_trtB[v_Sick_tunnel[n_tunnel_size], "D", ]  <- v_p_S1Dage


## ----------------------------------------------------------------------------------------------------------------
### Check if transition probability matrices are valid
## Check that transition probabilities are [0, 1]
check_transition_probability(a_P_tunnels)
check_transition_probability(a_P_tunnels_trtB)
## Check that all rows sum to 1
check_sum_of_transition_array(a_P_tunnels,      n_states = n_states_tunnels, 
                              n_cycles = n_cycles)
check_sum_of_transition_array(a_P_tunnels_trtB, n_states = n_states_tunnels, 
                              n_cycles = n_cycles)


## ----Init-Sick-Sicker-TimeDependent-Tunnels-Trace----------------------------------------------------------------
# Initialize cohort for state-residence cSTM under SoC
m_M_tunnels <- matrix(0, 
                      nrow = (n_cycles + 1), ncol = n_states_tunnels, 
                      dimnames = list(0:n_cycles, v_names_states_tunnels))
# Store the initial state vector in the first row of the cohort trace
m_M_tunnels[1, ] <- v_s_init_tunnels
## Initialize cohort trace under treatment B
m_M_tunnels_trtB <- m_M_tunnels


## ----Sick-Sicker-TimeDependent-Tunnels-Solution------------------------------------------------------------------
# Iterative solution of state-residence-dependent cSTM
for(t in 1:n_cycles){
  # For SoC
  m_M_tunnels[t + 1, ] <- m_M_tunnels[t, ] %*% a_P_tunnels[, , t]
  # Under treatment B
  m_M_tunnels_trtB[t + 1,] <- m_M_tunnels_trtB[t, ] %*% a_P_tunnels_trtB[, , t]
}


## ----------------------------------------------------------------------------------------------------------------
# Create aggregated trace
m_M_tunnels_sum <- cbind(H = m_M_tunnels[, "H"], 
                         S1 = rowSums(m_M_tunnels[, which(v_names_states=="S1"):
                                                    (n_tunnel_size +1)]), 
                         S2 = m_M_tunnels[, "S2"],
                         D = m_M_tunnels[, "D"])


## ----Sick-Sicker-TimeDependent-Surv------------------------------------------------------------------------------
v_S_ad <- rowSums(m_M_ad[, -which(v_names_states=="D")]) # vector with survival curve


## ----Sick-Sicker-Surv-TimeDep, echo=FALSE, fig.cap='Survival curve of time-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"----
ggplot(data.frame(Cycle = 0:n_cycles, Survival = v_S_ad), 
       aes(x = Cycle, y = Survival)) +
  geom_line(size = 1.3) +
  xlab("Cycle") +
  ylab("Proportion alive") +
  theme_bw(base_size = 16) +
  theme()


## ----Sick-Sicker-TimeDependent-Prevalence------------------------------------------------------------------------
v_prev_S1   <- m_M_ad[, "S1"] / v_S_ad          # vector with prevalence of Sick
v_prev_S2   <- m_M_ad[, "S2"] / v_S_ad          # vector with prevalence of Sicker
v_prev_S1S2 <- rowSums(m_M_ad[, c("S1", "S2")])/v_S_ad # prevalence of Sick and Sicker


## ----Sick-Sicker-Prev-TimeDep, echo=FALSE, fig.cap='Prevalence of sick states in age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"----
df_prev_states <- data.frame(Cycle = 0:n_cycles, 
                  States  = ordered(rep(c("S1", "S2", "S1 + S2"),
                                each = (n_cycles + 1)), 
                                levels = c("S1", "S2", "S1 + S2")), 
                  Prevalence = c(v_prev_S1, 
                                 v_prev_S2, 
                                 v_prev_S1S2))
ggplot(df_prev_states, 
       aes(x = Cycle, y = Prevalence, 
           color = States, linetype = States)) +
  geom_line(size = 1) +
  scale_x_continuous(breaks = number_ticks(8)) + 
  scale_y_continuous(labels = scales::percent_format(accuracy = 1)) + 
  scale_color_discrete(name = "Health State", l = 50) +
  scale_linetype(name = "Health State") +
  xlab("Cycle") +
  ylab("Prevalence (%)") +
  theme_bw(base_size = 16) +
  theme(legend.position = "bottom")


## ----Sick-Sicker-TimeDependent-PropS2----------------------------------------------------------------------------
# Vector with proportion of Sicker among sick individuals
v_prop_S2 <- m_M_ad[-1, "S2"] / v_prev_S1S2[-1] 


## ----Sick-Sicker-PropS2-TimeDep, echo=FALSE, fig.cap='Proportion of Sicker (S2) individuals among all sick patients of age-dependent cSTM', message=FALSE, warning=FALSE, fig.pos="H"----
ggplot(data.frame(Cycle = 1:n_cycles, 
                  Proportion = v_prop_S2), 
       aes(x = Cycle, y = Proportion)) +
  geom_line(size = 1) +
  scale_y_continuous(breaks = number_ticks(6)) + # labels = scales::percent
  scale_x_continuous(breaks = number_ticks(8)) +
  xlab("Cycle") +
  ylab("Proportion") +
  theme_bw(base_size = 16) +
  theme()


## ----Expected-life-years-NoShow, echo=FALSE----------------------------------------------------------------------
le_ad <- sum(v_S_ad)


## ----Life-expectancy, eval=FALSE---------------------------------------------------------------------------------
## le_ad <- sum(v_S_ad) # life expectancy


## ----State-rewards-UC--------------------------------------------------------------------------------------------
# Vector of state utilities under SOC
v_u_SoC <- c(H = u_H, S1 = u_S1, S2 = u_S2, D = u_D)
# Vector of state costs under SoC
v_c_SoC <- c(H = c_H, S1 = c_S1, S2 = c_S2, D = c_D)


## ----State-rewards-U-Tr------------------------------------------------------------------------------------------
# Vector of state utilities for strategy A
v_u_strA <- c(H = u_H, S1 = u_trtA, S2 = u_S2, D = u_D)
# Vector of state utilities for strategy B
v_u_strB <- v_u_SoC
# Vector of state utilities for strategy AB
v_u_strAB <- v_u_strA


## ----State-rewards-C-Tr------------------------------------------------------------------------------------------
# Vector of state costs for strategy A
v_c_strA <- c(H  = c_H, 
              S1 = c_S1 + c_trtA, 
              S2 = c_S2 + c_trtA, 
              D  = c_D)
# Vector of state costs for strategy B
v_c_strB <- c(H  = c_H, 
              S1 = c_S1 + c_trtB, 
              S2 = c_S2 + c_trtB, 
              D  = c_D)
# Vector of state costs for strategy AB
v_c_strAB <- c(H  = c_H, 
               S1 = c_S1 + (c_trtA + c_trtB), 
               S2 = c_S2 + (c_trtA + c_trtB), 
               D  = c_D)


## ----Expected-outcomes-each-cycle--------------------------------------------------------------------------------
# Vector of QALYs under SoC
v_qaly_SoC <- m_M_ad %*% v_u_SoC
# Vector of costs under SoC
v_cost_SoC <- m_M_ad %*% v_c_SoC
# Vector of QALYs for strategy A
v_qaly_strA <- m_M_ad %*% v_u_strA
# Vector of costs for strategy A
v_cost_strA <- m_M_ad %*% v_c_strA
# Vector of QALYs for strategy B
v_qaly_strB <- m_M_ad_trtB %*% v_u_strB
# Vector of costs for strategy B
v_cost_strB <- m_M_ad_trtB %*% v_c_strB
# Vector of QALYs for strategy AB
v_qaly_strAB <- m_M_ad_trtB %*% v_u_strAB
# Vector of costs for strategy AB
v_cost_strAB <- m_M_ad_trtB %*% v_c_strAB


## ----within-cycle-vector-----------------------------------------------------------------------------------------
## Vector with cycles
v_cycles <- seq(1, n_cycles+1)
## Generate 2/3 and 4/3 multipliers for even and odd entries, respectively
v_wcc <- ((v_cycles %% 2)==0)*(2/3) + ((v_cycles %% 2)!=0)*(4/3)
## Substitute 1/3 in first and last entries
v_wcc[1] <- v_wcc[n_cycles + 1] <- 1/3


## ----Discount vectors--------------------------------------------------------------------------------------------
# Discount weight for effects
v_dwe <- 1 / ((1 + d_e) ^ (0:(n_cycles)))  
# Discount weight for costs 
v_dwc <- 1 / ((1 + d_c) ^ (0:(n_cycles)))    


## ----Expected-outcomes-all-cycles--------------------------------------------------------------------------------
## Expected discounted QALYs under SoC
n_tot_qaly_SoC <- t(v_qaly_SoC) %*% (v_dwe * v_wcc)
## Expected discounted costs under SoC
n_tot_cost_SoC <- t(v_cost_SoC) %*% (v_dwc * v_wcc)
## Expected discounted QALYs for strategy A
n_tot_qaly_strA <- t(v_qaly_strA) %*% (v_dwe * v_wcc)
## Expected discounted costs for strategy A
n_tot_cost_strA <- t(v_cost_strA) %*% (v_dwc * v_wcc)
## Expected discounted QALYs for strategy B
n_tot_qaly_strB <- t(v_qaly_strB) %*% (v_dwe * v_wcc)
## Expected discounted costs for strategy B
n_tot_cost_strB <- t(v_cost_strB) %*% (v_dwc * v_wcc)
## Expected discounted QALYs for strategy AB
n_tot_qaly_strAB <- t(v_qaly_strAB) %*% (v_dwe * v_wcc)
## Expected discounted costs for strategy AB
n_tot_cost_strAB <- t(v_cost_strAB) %*% (v_dwc * v_wcc)


## ----Expected-outcomes, echo=FALSE, message=FALSE, warning=FALSE-------------------------------------------------
m_outcomes <- matrix(c(dollar(c(n_tot_cost_SoC, n_tot_cost_strA, 
                                n_tot_cost_strB, n_tot_cost_strAB)),
                       format(round(c(n_tot_qaly_SoC, n_tot_qaly_strA, 
                               n_tot_qaly_strB, n_tot_qaly_strAB), 3), nsmall = 3)),
                     ncol = 2, nrow = length(v_names_str), 
                     dimnames = list(v_names_str,
                                     c("Costs", "QALYs")))
kable(m_outcomes, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Total expected discounted QALYs and costs per average individual in the cohort of the age-dependent Sick-Sicker model by strategy accounting for within-cycle correction .", 
      align = c("l", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")


## ----Init-Transition-Array---------------------------------------------------------------------------------------
# Initialize transition-dynamics array under SoC
a_A <- array(0,
             dim = c(n_states, n_states, (n_cycles + 1)),
             dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Set first slice to the initial state vector in its diagonal
diag(a_A[, , 1]) <- v_s_init
# Initialize transition-dynamics array under treatment B
a_A_trtB <- a_A


## ----Compute-Transition-Array------------------------------------------------------------------------------------
# Iterative solution to produce the transition-dynamics array
for (t in 1:n_cycles){
  # For SoC
  a_A[, , t + 1] <- diag(m_M_ad[t, ]) %*% a_P[, , t]
  # For treatment B
  a_A_trtB[, , t + 1] <- m_M_ad_trtB[t, ]  * a_P_trtB[, , t]
}


## ----Init-Reward-Array-------------------------------------------------------------------------------------------
# Arrays of state and transition rewards
# Utilities under SoC
a_R_u_SoC <- array(matrix(v_u_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under SoC
a_R_c_SoC <- array(matrix(v_c_SoC, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy A
a_R_u_strA <-  array(matrix(v_u_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy A
a_R_c_strA <- array(matrix(v_c_strA, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy B
a_R_u_strB <-  array(matrix(v_u_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy B
a_R_c_strB <- array(matrix(v_c_strB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Utilities under Strategy AB
a_R_u_strAB <-  array(matrix(v_u_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))
# Costs under Strategy AB
a_R_c_strAB <- array(matrix(v_c_strAB, nrow = n_states, ncol = n_states, byrow = T), 
                  dim = c(n_states, n_states, n_cycles + 1),
                  dimnames = list(v_names_states, v_names_states, 0:n_cycles))


## ----Add-DisUtility-Tr-------------------------------------------------------------------------------------------
# Add disutility due to transition from Healthy to Sick
a_R_u_strA["H", "S1", ] <- a_R_u_strA["H", "S1", ] - du_HS1


## ----Add-IncCosts-Tr---------------------------------------------------------------------------------------------
# Add transition cost due to transition from Healthy to Sick
a_R_c_strA["H", "S1", ] <- a_R_c_strA["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strA[-n_states, "D", ] <- a_R_c_strA[-n_states, "D", ] + ic_D
a_R_c_strA[, , 1]


## ----Add-TransReward-UC------------------------------------------------------------------------------------------
## SoC
# Add disutility due to transition from H to S1
a_R_u_SoC["H", "S1", ] <- a_R_u_SoC["H", "S1", ] - du_HS1
# Add transition cost due to transition from H to S1
a_R_c_SoC["H", "S1", ] <- a_R_c_SoC["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_SoC[-n_states, "D", ] <- a_R_c_SoC[-n_states, "D", ] + ic_D

## Strategy B
# Add disutility due to transition from Healthy to Sick
a_R_u_strB["H", "S1", ] <- a_R_u_strB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strB["H", "S1", ] <- a_R_c_strB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strB[-n_states, "D", ] <- a_R_c_strB[-n_states, "D", ] + ic_D

## Strategy AB
# Add disutility due to transition from Healthy to Sick
a_R_u_strAB["H", "S1", ] <- a_R_u_strAB["H", "S1", ] - du_HS1
# Add transition cost due to transition from Healthy to Sick
a_R_c_strAB["H", "S1", ] <- a_R_c_strAB["H", "S1", ] + ic_HS1
# Add transition cost of dying from all non-dead states
a_R_c_strAB[-n_states, "D", ] <- a_R_c_strAB[-n_states, "D", ] + ic_D


## ----Expected-Outcomes-Transitions-Cycle-------------------------------------------------------------------------
# For SoC
a_Y_c_SoC <- a_A * a_R_c_SoC
a_Y_u_SoC <- a_A * a_R_u_SoC
# For Strategy A
a_Y_c_strA <- a_A * a_R_c_strA
a_Y_u_strA <- a_A * a_R_u_strA
# For Strategy B
a_Y_c_strB <- a_A_trtB * a_R_c_strB
a_Y_u_strB <- a_A_trtB * a_R_u_strB
# For Strategy AB
a_Y_c_strAB <- a_A_trtB * a_R_c_strAB
a_Y_u_strAB <- a_A_trtB * a_R_u_strAB


## ----Expected-Outcomes-Cycle-------------------------------------------------------------------------------------
# Vectors of rewards
# QALYs under SoC
v_qaly_SoC <- rowSums(t(colSums(a_Y_u_SoC)))
# Costs under SoC
v_cost_SoC <- rowSums(t(colSums(a_Y_c_SoC)))
# QALYs under Strategy A
v_qaly_strA <- rowSums(t(colSums(a_Y_u_strA)))
# Costs under Strategy A
v_cost_strA <- rowSums(t(colSums(a_Y_c_strA)))
# QALYs under Strategy B
v_qaly_strB <- rowSums(t(colSums(a_Y_u_strB)))
# Costs under Strategy B
v_cost_strB <- rowSums(t(colSums(a_Y_c_strB)))
# QALYs under Strategy AB
v_qaly_strAB <- rowSums(t(colSums(a_Y_u_strAB)))
# Costs under Strategy AB
v_cost_strAB <- rowSums(t(colSums(a_Y_c_strAB)))


## ----------------------------------------------------------------------------------------------------------------
### For SoC
## QALYs
n_tot_qaly_SoC <- t(v_qaly_SoC) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_SoC <- t(v_cost_SoC) %*% (v_dwc * v_wcc)
### For Strategy A
## QALYs
n_tot_qaly_strA <- t(v_qaly_strA) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strA <- t(v_cost_strA) %*% (v_dwc * v_wcc)
### For Strategy B
## QALYs
n_tot_qaly_strB <- t(v_qaly_strB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strB <- t(v_cost_strB) %*% (v_dwc * v_wcc)
### For Strategy AB
## QALYs
n_tot_qaly_strAB <- t(v_qaly_strAB) %*% (v_dwe * v_wcc)
## Costs
n_tot_cost_strAB <- t(v_cost_strAB) %*% (v_dwc * v_wcc)


## ----CEA-analysis------------------------------------------------------------------------------------------------
### Vector of costs
v_cost_str <- c(n_tot_cost_SoC, n_tot_cost_strA, n_tot_cost_strB, n_tot_cost_strAB)
### Vector of effectiveness
v_qaly_str <- c(n_tot_qaly_SoC, n_tot_qaly_strA, n_tot_qaly_strB, n_tot_qaly_strAB)

### Calculate incremental cost-effectiveness ratios (ICERs)
df_cea <- dampack::calculate_icers(cost = v_cost_str, 
                                   effect = v_qaly_str,
                                   strategies = v_names_str)


## ----CEA-table, echo=FALSE---------------------------------------------------------------------------------------
table_cea <- df_cea
## Format column names
colnames(table_cea)[2:6] <- c("Costs ($)", "QALYs", 
                          "Incremental Costs ($)", "Incremental QALYs", 
                          "ICER ($/QALY)") # name the columns
table_cea$`Costs ($)` <- comma(round(table_cea$`Costs ($)`, 0))
table_cea$`Incremental Costs ($)` <- comma(round(table_cea$`Incremental Costs ($)`, 0))
table_cea$QALYs <- round(table_cea$QALYs, 3)
table_cea$`Incremental QALYs` <- round(table_cea$`Incremental QALYs`, 3)
table_cea$`ICER ($/QALY)` <- comma(round(table_cea$`ICER ($/QALY)`, 0))


## ----table-cea, echo=FALSE, message=FALSE, warning=FALSE---------------------------------------------------------
kable(table_cea, 
      format = ifelse(doc_type == "docx", "markdown", "latex"),  
      booktabs = TRUE,
      caption = "Cost-effectiveness analysis results for the age-dependent Sick-Sicker model. ND: Non-dominated strategy; D: Dominated strategy.",
      align = c("r", "c", "c", "c", "c", "c", "c")) %>%
  kable_styling(latex_options = "hold_position")


## ----Sick-Sicker-CEA-AgeDep, echo=FALSE, fig.cap='Cost-effectiveness efficient frontier of all four strategies for the age-dependent Sick-Sicker model.', message=FALSE, warning=FALSE, fig.pos="H"----
plot(df_cea, label = "all", txtsize = 16) +
  expand_limits(x = c(NA, 21.8)) +
  theme(legend.position = c(0.8, 0.2))


## ----PSA-setup, eval=TRUE, echo=FALSE----------------------------------------------------------------------------
# Number of PSA samples
n_sim <- 1000
# Generate PSA input dataset
df_psa_input <- generate_psa_params(n_sim = n_sim)

# Initialize matrices with PSA output 
# Dataframe of costs
df_c <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_c) <- v_names_str
# Dataframe of effectiveness
df_e <- as.data.frame(matrix(0, 
                             nrow = n_sim,
                             ncol = n_str))
colnames(df_e) <- v_names_str


## ----PSA-run, eval=TRUE, echo=FALSE, cache=TRUE, message=FALSE, warning=FALSE------------------------------------
## Conduct probabilistic sensitivity analysis
# Run Markov model on each parameter set of PSA input dataset
for(i in 1:n_sim){
  l_out_temp <- calculate_ce_out(l_params_all = df_psa_input[i, ])
  df_c[i, ]  <- l_out_temp$Cost  
  df_e[i, ]  <- l_out_temp$Effect
  # Display simulation progress
  # if(i/(n_sim/100) == round(i/(n_sim/100), 0)) { # display progress every 5%
  #   cat('\r', paste(i/n_sim * 100, "% done", sep = " "))
  # }
}


## ----Generate-PSA-object, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE------------------------------------
# Create PSA object for dampack
l_psa <- make_psa_obj(cost          = df_c, 
                      effectiveness = df_e, 
                      parameters    = df_psa_input, 
                      strategies    = v_names_str)
l_psa$strategies <- v_names_str
colnames(l_psa$effectiveness)<- v_names_str
colnames(l_psa$cost)<- v_names_str

# Vector with willingness-to-pay (WTP) thresholds.
v_wtp <- seq(0, 200000, by = 5000)

## Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF)
ceac_obj <- ceac(wtp = v_wtp, psa = l_psa)
ceac_obj$Strategy <- ordered(ceac_obj$Strategy, v_names_str)

##  Expected Loss Curves (ELCs)
elc_obj <- calc_exp_loss(wtp = v_wtp, psa = l_psa)


## ----CEAC, echo=FALSE, fig.cap='Cost-effectiveness acceptability curves (CEACs) and frontier (CEAF).', message=FALSE, warning=FALSE, fig.pos="H"----
# CEAC & CEAF plot
plot(ceac_obj, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14) +
  theme(legend.position = c(0.8, 0.5))


## ----ELC, echo=FALSE, fig.cap='Expected loss curves (ELCs) and expected value of perfect information (EVPI).', message=FALSE, warning=FALSE, fig.pos="H"----
# ELC plot
plot(elc_obj, log_y = FALSE, txtsize = 16, xlim = c(0, NA), n_x_ticks = 14,
     col = "full") +
  # geom_point(aes(shape = as.name("Strategy"))) +
  scale_y_continuous("Expected Loss (Thousand $)", 
                     breaks = number_ticks(10),
                     labels = function(x) x/1000) +
  theme(legend.position = c(0.4, 0.7))

